#!/usr/bin/perl

use warnings;
use strict;
#use Data::Dumper;
use Getopt::Long qw(:config bundling no_auto_abbrev);
# bundling is combining multiple short options together,
# no_auto_abbrev makes sure the error messages never
# abbreviate the parameter that was unknown.

my ($doit, $frc, $rem) = (0, 0 ,0);
my $urcd = "update-rc.d";
my $root = "";
my %init;

my $res = GetOptions(	
		"a|apply" => \$doit,
		"f|force" => \$frc,
		"r|remove" => sub { $rem = 1; $frc = 1; }, 
		"root=s" => \$root
	);
#print "\$res='$res'\n";
#print <<_EOF_
#apply(\$doit)='$doit'
#force(\$frc)='$frc'
#remove(\$rem)='$rem'
#root(\$root)='$root'
#_EOF_
#;

#print "\@ARGV='@ARGV'\n";
$init{$_}++ for (@ARGV);

#print Dumper \%init;
#exit;


my %info;
for my $lvl (0..6, "S") { 
	for (glob "/etc/rc${lvl}.d/[KS]*") {
		next unless -L;
		next unless my ($rlev, $sk, $pri, $svc) = m|/rc(.)\.d/([SK])([0-9]{2})(.+)$|;
		push(@{$info{$svc}{$sk}{$pri}}, $rlev);
	}
}

#print Dumper \%info;
#exit;


for my $svc (sort keys %info) {
	my @par = ();
	$frc and push @par, "-f";

	if (%init) { next unless exists $init{$svc}; }
	
	next if not -x $root . "/etc/init.d/" . $svc;
	
	my @s = keys %{$info{$svc}{S}};
	my @k = keys %{$info{$svc}{K}};
	
	if ($rem) {
		push @par, $svc, "remove";
	}
	elsif ("@s" eq "20" and "@{$info{$svc}{S}{20}}" eq "2 3 4 5" and 
	    "@k" eq "20" and "@{$info{$svc}{K}{20}}" eq "0 1 6") { 
		push @par, $svc, "defaults";
	}
	else {
		my $prm = undef; 
		$prm .= "start $_ @{$info{$svc}{S}{$_}} . " for (@s);
		$prm .= "stop $_ @{$info{$svc}{K}{$_}} . " for (@k);
		push @par, $svc, $prm if ($prm);
	}
	
	print "$urcd @par\n";
	system($urcd, @par) if $doit eq "yes";
}
