#!/bin/sh
#
# Copyright: (C) 2008 Kel Modderman <kel@otaku42.de>
# License:   GPLv2
#

PATH=/usr/bin:/bin:/usr/sbin:/sbin

if [ "$(id -u)" -eq 0 ]; then
	ROOT=:
else
	ROOT=false
fi

OPT_AUTOMNT=false
OPT_DEBUG=false
OPT_LABELS=false
OPT_LIVEONLY=false
OPT_MKMNTPNT=false
OPT_NOMNTPNT=false
OPT_NOSWAP=false
OPT_UUIDS=false
OPT_WANTED=false

# Default output file is stdout
OPT_FILE=/dev/stdout

OPT_CLIARGS=$(getopt --options adf:lmnsuw: \
		  --longoptions auto,debug,file:,labels,mkdir,nomnt,swapless,uuids,wanted: \
		  --name "${0}" -- "${@}")

if [ "${?}" -eq 0 ]; then
	eval set -- "${OPT_CLIARGS}"
else
	echo "getopt terminated abnormally" >/dev/stderr
	exit 255
fi

while :; do
	case "${1}" in
		-a|--auto)
			OPT_AUTOMNT=:
			;;
		-d|--debug)
			if ${OPT_DEBUG}; then
				set -x
			else
				OPT_DEBUG=:
			fi
			;;
		-f|--file)
			shift
			OPT_FILE="${1}"
			;;
		-l|--labels)
			OPT_LABELS=:
			;;
		-m|--mkdir)
			OPT_MKMNTPNT=:
			;;
		-n|--nomnt)
			OPT_NOMNTPNT=:
			;;
		-s|--swapless)
			OPT_NOSWAP=:
			;;
		-u|--uuids)
			OPT_UUIDS=:
			;;
		-w|--wanted)
			OPT_WANTED=:
			shift
			OPT_WANTED_DEVICES="${OPT_WANTED_DEVICES} ${1}"
			;;
		--)
			shift
			break
			;;
	esac
	shift
done

#
# output debug starting with 'D:' to stderr
#
dbg()
{
	${OPT_DEBUG} && echo "D: ${@}" >/dev/stderr
}

#
# output warning starting with 'W:' to stderr
#
warn()
{
	echo "W: ${@}" >/dev/stderr
}

#
# future proof udev info query tool command
#
if which udevadm >/dev/null; then
	udev_info()
	{
		udevadm info --query="${1}" --name="${2}"
	}
	udev_blkdev_trigger()
	{
		udevadm trigger --subsystem-match=block
		udevadm settle --timeout=30
	}
else
	udev_info()
	{
		udevinfo --query="${1}" --name="${2}"
	}
	udev_blkdev_trigger()
	{
		udevtrigger --subsystem-match=block
		udevsettle --timeout=30
	}
fi

if ! ${ROOT}; then
	volumeid()
	{
		return
	}
elif which vol_id >/dev/null; then
	volumeid()
	{
		vol_id "/dev/${1}"
	}
else
	volumeid()
	{
		/lib/udev/vol_id "/dev/${1}"
	}
fi

#
# output udev enironment information for a block device
#
disk_env()
{
	[ -b "/dev/${1}" ] && udev_info env "/dev/${1}" 2>/dev/null
}

#
# output udev symlink information for a block device
#
disk_symlinks()
{
	[ -b "/dev/${1}" ] && udev_info symlink "/dev/${1}" 2>/dev/null
}

#
# test block device "removable" attribute
#
is_removable()
{
	local rem

	if [ -f "${1}/removable" ]; then
		read rem < "${1}/removable"
	else
		warn "${1}/removable does not exist"
		# treat it as removable
		return 0
	fi

	case "${rem}" in
		0)
			# fixed disk
			return 1
			;;
		1|*)
			# removable or unknown disk
			return 0
			;;
	esac
}

#
# return true for Linux native filesystems
#
is_nativefs()
{
	case "${1}" in
		ext[2-4]|reiser*|[jx]fs|swap)
			return 0
			;;
		*)
			return 1
			;;
	esac
}

#
# check for mounted device and return mount point
#
is_mounted()
{
	local mntpnt

	for d in ${@}; do
		mntpnt=$(sed -n "s%^/dev/${d} \([^[:space:]]\+\).*%\1%p" \
				/proc/mounts | head -n1)
		if [ -d "${mntpnt}" ]; then
			echo "${mntpnt}"
			break
		fi
	done
}

#
# we really want this device to be in fstab, even if it doesn't usually qualify
# to be there (eg. usb disk)
#
is_wanted()
{
	local name node
	name="${1}"
	node="/dev/${1}"

	if ! ${OPT_WANTED}; then
		return 1
	fi

	for device in ${OPT_WANTED_DEVICES}; do
		[ "${name}" = "${device}" ] && return 0
		[ "${node}" = "${device}" ] && return 0
	done

	return 1
}

#
# conditionally make mount point directories
#
mkmntpnt()
{
	${OPT_MKMNTPNT} && mkdir -p "${1}"
}

#
# private function to control formatting of printed output
#
_printf_mntent()
{
	if ${OPT_UUIDS} || [ "${#1}" -ge 20 ]; then
		printf "%-45s %-30s %-15s %-40s %-6s %s\n\n" \
		       "${1}" "${2}" "${3}" "${4}" "${5}" "${6}" >>"${OPT_FILE}"
	else
		printf "%-20s %-30s %-15s %-40s %-6s %s\n\n" \
		       "${1}" "${2}" "${3}" "${4}" "${5}" "${6}" >>"${OPT_FILE}"
	fi
}

#
# create state directory
#
set -e
FSTAB_STATE_DIR=$(mktemp -p /tmp -d fstab.XXXX)
trap "{
	if [ -d \"${FSTAB_STATE_DIR}\" ]; then
		find \"${FSTAB_STATE_DIR}\" -delete
	fi
}" EXIT
set +e

#
# utility to store state of unique fsentry attributes
#
record_state_of()
{
	[ "${1}" ] || return 1

	if [ "${#}" -eq 1 ] && mkdir "${FSTAB_STATE_DIR}/${1}"; then
		return 0
	elif [ -d "${FSTAB_STATE_DIR}/${1}" ]; then
		warn "already recorded state of: ${1}"
		warn "${1} is not unique"
	else
		warn "failed to record state of: ${*}"
		warn "${*} is invalid"
	fi

	return 1
}

#
# print fstab entry for a filesystem
#
print_fsentry()
{
	local fs_spec fs_file fs_vfstype fs_mntops fs_freq fs_passno

	local name disk part
	name="${1}"
	disk="${2}"

	local mounted label_is_safe symlinks
	mounted=false
	label_is_safe=false

	unset ID_FS_TYPE ID_FS_USAGE \
	      ID_FS_LABEL_ENC ID_FS_LABEL_SAFE \
	      ID_FS_UUID_ENC

	case "${name}" in
		mapper/*)
			eval "$(volumeid ${name} | sed  -e 's@^\(ID_FS_[^=]\+\)=\(.*\)$@\1='\''\2'\''@g' | \
						   grep -e '^ID_FS_TYPE=' \
							-e '^ID_FS_USAGE=' \
							-e '^ID_FS_LABEL_ENC=' \
							-e '^ID_FS_LABEL_SAFE=' \
							-e '^ID_FS_UUID_ENC=')"

			symlinks=""
			;;
		*)
			eval "$(disk_env ${name} | sed  -e 's@^\(ID_FS_[^=]\+\)=\(.*\)$@\1='\''\2'\''@g' | \
						   grep -e '^ID_FS_TYPE=' \
							-e '^ID_FS_USAGE=' \
							-e '^ID_FS_LABEL_ENC=' \
							-e '^ID_FS_LABEL_SAFE=' \
							-e '^ID_FS_UUID_ENC=')"

			symlinks=$(disk_symlinks ${name})
			;;
	esac

	if [ "${ID_FS_USAGE}" != "filesystem" ] && \
	   [ "${ID_FS_TYPE}" != "swap" ]; then
		dbg "partition not a valid filesystem: ${name}"
		return
	elif [ "${ID_FS_TYPE}" = "swap" ] && ${OPT_NOSWAP}; then
		dbg "ignoring swap partition"
		return
	fi

	#
	# fs_spec - first field describes the block special device or remote
	#           filesystem to be mounted
	#
	if ${OPT_LABELS} && record_state_of "${ID_FS_LABEL_ENC}"; then
		[ "${ID_FS_LABEL_SAFE}" ] && label_is_safe=:

		if is_nativefs "${ID_FS_TYPE}"; then
			# volume_id returns labels with spaces escaped with:
			#   '\x20'
			# mount(8) expects space characters to be escaped with:
			#   '\040'
			fs_spec=$(echo "LABEL=${ID_FS_LABEL_ENC}" | \
					sed -e 's@\\x20@\\040@g')
		else
			fs_spec="/dev/disk/by-label/${ID_FS_LABEL_ENC}"
		fi
	elif ${OPT_UUIDS} && record_state_of "${ID_FS_UUID_ENC}"; then
		if is_nativefs "${ID_FS_TYPE}"; then
			fs_spec="UUID=${ID_FS_UUID_ENC}"
		else
			fs_spec="/dev/disk/by-uuid/${ID_FS_UUID_ENC}"
		fi
	else
		fs_spec="/dev/${name}"
	fi

	#
	# fs_file - second field describes the mount point for the filesystem
	#
	if [ "${ID_FS_TYPE}" = "swap" ]; then
		fs_file="none"
	elif ! ${OPT_NOMNTPNT}; then
		fs_file=$(is_mounted ${name} ${symlinks})
	fi

	if [ "${fs_file}" ]; then
		dbg "${name} is mounted on ${fs_file}"
		mounted=:
	elif ${label_is_safe}; then
		fs_file="/media/${ID_FS_LABEL_SAFE}"
	else
		case "${name}" in
			mapper/*)
				fs_file="${name#mapper/}"
				;;
			*)
				part=$(echo ${name} | egrep -o '[[:digit:]]+$')
				
				if [ "${part}" ]; then
					fs_file="disk${disk}part${part}"
				else
					dbg "partition index invalid"
					continue
				fi
				;;
		esac

		if record_state_of "${fs_file}"; then
			fs_file="/media/${fs_file}"
		else
			return
		fi
	fi

	#
	# fs_vfstype - third field describes the type of the filesystem
	#
	fs_vfstype="${ID_FS_TYPE}"

	#
	# fs_mntops - fourth field describes the mount options associated with
	#             the filesystem
	#
	if ${OPT_AUTOMNT}; then
		fs_mntops="auto,users"
	else
		fs_mntops="noauto,users"
	fi

	case "${ID_FS_TYPE}" in
		ntfs)
			fs_mntops="${fs_mntops},ro,dmask=0022,fmask=0133,nls=utf8"
			;;
		msdos)
			fs_mntops="${fs_mntops},rw,quiet,umask=000,iocharset=utf8"
			;;
		vfat)
			fs_mntops="${fs_mntops},rw,quiet,umask=000,shortname=lower"
			;;
		hfsplus)
			fs_mntops="${fs_mntops},ro,exec"
			;;
		swap)
			fs_mntops="sw"
			;;
		*)
			if ! is_nativefs "${ID_FS_TYPE}"; then
				dbg "unhandled filesystem type: ${ID_FS_TYPE}"
				return
			fi

			if ${mounted}; then
				case "${fs_file}" in
					/media/*)
						fs_mntops="${fs_mntops},rw,exec,noatime"
						;;
					/)
						case "${ID_FS_TYPE}" in
							ext[23])
								fs_mntops="defaults,errors=remount-ro,noatime"
								;;
							*)
								fs_mntops="defaults,noatime"
								;;
						esac
						;;
					*)
						fs_mntops="defaults,noatime"
						;;
				esac
			else
				fs_mntops="${fs_mntops},rw,exec,noatime"
			fi
			;;
	esac

	#
	# fs_freq - fifth field is used for these filesystems by the dump(8)
	#           command
	#
	fs_freq=0

	#
	# fs_passno - sizth field is used by the fsck(8) program to determine
	#             the order in which filesystem checks are done at bootup
	#
	if is_nativefs "${ID_FS_TYPE}" && ! ${OPT_NOMNTPNT}; then
		case "${fs_file}" in
			/)
				fs_passno=1
				;;
			none)
				# swap
				fs_passno=0
				;;
			*)
				fs_passno=2
				;;
		esac
	else
		fs_passno=0
	fi

	_printf_mntent "${fs_spec}" "${fs_file}" "${fs_vfstype}" \
		       "${fs_mntops}" "  ${fs_freq}" "  ${fs_passno}"

	mkmntpnt "${fs_file}"
}

#
# scan for block devices
#
scan_disks()
{
	local name disk partitions
	disk=1

	for p in /sys/block/*; do
		[ -d "${p}" ] || continue

		name="${p#/sys/block/}"

		unset ID_BUS ID_TYPE
		eval "$(disk_env ${name} | grep -e '^ID_BUS=' \
						-e '^ID_TYPE=')"

		dbg "sysfs path: ${p}"
		dbg "ID_BUS=${ID_BUS} ID_TYPE=${ID_TYPE}"

		if is_wanted "${name}"; then
			: # do not filter out this device
		elif [ "${ID_TYPE}" != disk ]; then
			dbg "device is not of disk type, skip"
			continue
		elif [ "${ID_BUS}" = "usb" ]; then
			dbg "device is on usb bus, skip"
			continue
		elif is_removable "${p}"; then
			dbg "device has removable attribute, skip"
			continue
		fi

		case "${name}" in
			[sh]d*)
				dbg "device is a disk, count: ${disk}"
				partitions=$(find -L "${p}" -maxdepth 1 \
							    -name "${name}[0-9]*" \
							    -printf "%P\n")

				for partition in ${partitions}; do
					print_fsentry "${partition}" "${disk}"
				done

				disk=$((disk + 1))
				;;
			dm-[0-9]*)
				dbg "device is a virtual block device"
				;;
			*)
				warn "disk device unhandled: ${name} (${p})"
				;;
		esac
	done
}

#
# scan for virtual (device mapper) block devices
#
scan_virtual_disks()
{
	for b in /dev/mapper/*; do
		[ -b "${b}" ] && print_fsentry "${b#/dev/}"
	done
}

#
# scan for cdom devices to add to fstab
# NOTE: /dev/cdrom* are persistent symlinks managed by
#   /etc/udev/rules.d/z25_persistent-cd.rules
#
scan_cdroms()
{
	local fs_spec fs_file fs_vfstype fs_mntops fs_freq fs_passno
	fs_vfstype="udf,iso9660"
	fs_mntops="noauto,ro,users"
	fs_freq=0
	fs_passno=0

	for c in /dev/cdrom*; do
		[ -L "${c}" ] || continue

		fs_spec="${c}"
		fs_file="/media/${c#/dev/}"

		_printf_mntent "${fs_spec}" "${fs_file}" "${fs_vfstype}" \
			       "${fs_mntops}" "  ${fs_freq}" "  ${fs_passno}"

		mkmntpnt "${fs_file}"
	done
}

#
# scan for floppy devices to add to fstab
#
scan_floppies()
{
	local fs_spec fs_file fs_vfstype fs_mntops fs_freq fs_passno
	fs_vfstype="auto"
	fs_mntops="noauto,rw,users"
	fs_freq=0
	fs_passno=0

	for f in /dev/fd*; do
		[ -b "${f}" ] || continue

		fs_spec="${f}"
		fs_file="/media/${f#/dev/}"

		_printf_mntent "${fs_spec}" "${fs_file}" "${fs_vfstype}" \
			       "${fs_mntops}" "  ${fs_freq}" "  ${fs_passno}"

		mkmntpnt "${fs_file}"
	done
}

fstab_header()
{
	cat >"${OPT_FILE}" <<EOF
# /etc/fstab - static information about the filesystems - fstab(5)
#
# /etc/fstab is only read by programs, and not written; it is the duty of the
# system administrator to properly maintain this file.
#
# Instead  of giving the device explicitly, one may indicate the filesystem
# that is to be mounted by its UUID or VOLUME label. This will make the
# system more robust: adding or removing a disk changes the disk device name
# but not the filesystem UUID or VOLUME label.
#
EOF

	_printf_mntent "# <filesystem>" "<mount point>" "<fstype>" \
		       "<mount options>" "<dump>" "<pass>"
}

fstab_header

udev_blkdev_trigger

scan_disks
scan_virtual_disks
scan_cdroms
scan_floppies
