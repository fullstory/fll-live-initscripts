#!/bin/sh

OPT_DEBUG=false
OPT_UUIDS=false
OPT_LABELS=false
OPT_AUTOMNT=false
OPT_MKMNTPNT=false

#
# future proof udev info query tool command
#
if which udevadm >/dev/null; then
	udev_info() { udevadm info --query="${1}" --name="${2}"; }
else
	udev_info() { udevinfo --query="${1}" --name="${2}"; }
fi

#
# output udev enironment information for a block device
#
disk_env()
{
	[ -b "/dev/${1}" ] || return 1

	udev_info env "/dev/${1}" 2>/dev/null
}

#
# resolve canonical device node
#
resolve_device()
{
	local name

	case "${1}" in
		LABEL=*|UUID=*)
			name="$(findfs ${1})"
			;;
		/dev/disk/by-*)
			name="$(readlink -f ${1})"
			;;
		/dev/*)
			name="${1}"
			;;
	esac

	if [ -b "${name}" ]; then
		echo "${name}"
	fi
}

#
# test block device "removable" attribute
#
is_removable()
{
	! grep -s -q '^0$' "${1}/removable"
}

#
# return true for Linux native filesystems
#
is_nativefs()
{
	case "${1}" in
		ext[2-4]|reiser*|[jx]fs|swap)
			return 0
			;;
		*)
			return 1
			;;
	esac
}

#
# conditionally make mount point directories
#
mkmntpnt()
{
	if ${OPT_MKMNTPNT}; then
		mkdir -p "${1}"
	fi
}

#
# output debug starting with 'D:' to stderr
#
debugstr()
{
	if ${OPT_DEBUG}; then
		echo "D: ${@}" >/dev/stderr
	fi
}

#
# print fstab entry for a filesystem
#
print_fsentry()
{
	local fs_spec fs_file fs_vfstype fs_mntops fs_freq fs_passno
	local name mntpnt type uuid label mounted
	name="${1}"
	mntpnt="${2}"
	type="${3}"
	uuid="${4}"
	label="${5}"
	mounted="false"

	#
	# fs_spec - first field describes the block special device or remote
	#           filesystem to be mounted
	#
	if ${OPT_LABELS} && [ -L "/dev/disk/by-label/${label}" ]; then
		if is_nativefs "${type}"; then
			fs_spec="LABEL=${label}"
		else
			fs_spec="/dev/disk/by-label/${label}"
		fi
	elif ${OPT_UUIDS} && [ -L "/dev/disk/by-uuid/${uuid}" ]; then
		if is_nativefs "${type}"; then
			fs_spec="UUID=${uuid}"
		else
			fs_spec="/dev/disk/by-uuid/${uuid}"
		fi
	else
		fs_spec="/dev/${name}"
	fi

	#
	# fs_file - second field describes the mount point for the filesystem
	#
	if [ "${mntpnt}" ]; then
		mounted=:
		fs_file="${mntpnt}"
	else
		case "${name}" in
			dm-*)
				mnt="/media/${name}"
				;;
			*)
				part="$(echo ${name} | egrep -o '[[:digit:]]+$')"
				
				if [ "${part}" ]; then
					mnt="/media/disk${disk}part${part}"
				else
					debugstr "partition index invalid"
					continue
				fi
				;;
		esac
	fi

	#
	# fs_vfstype - third field describes the type of the filesystem
	#
	fs_vfstype="${type}"

	#
	# fs_mntops - fourth field describes the mount options associated with
	#             the filesystem
	#
	if ${OPT_AUTOMNT}; then
		fs_mntops="auto"
	else
		fs_mntops="noauto"
	fi

	case "${type}" in
		ntfs)
			fs_mntops="${fs_mntops},ro,dmask=0022,fmask=0133,nls=utf8"
			;;
		msdos)
			fs_mntops="${fs_mntops},quiet,umask=000,iocharset=utf8"
			;;
		vfat)
			fs_mntops="${fs_mntops},shortname=lower,quiet,umask=000"
			;;
		swap)
			fs_mntops="sw"
			;;
		*)
			if is_nativefs "${type}"; then
				if ${mounted}; then
					fs_mntops="defaults,noatime"
				else
					fs_mntops="${fs_mntops},users,exec,noatime"
				fi
			else
				fs_mntops="${fs_mntops},defaults"
			fi
			;;
	esac

	#
	# fs_freq - fifth field is used for these filesystems by the dump(8)
	#           command
	#
	fs_freq=0

	#
	# fs_passno - sizth field is used by the fsck(8) program to determine
	#             the order in which filesystem checks are done at bootup
	#
	if ${mounted} && [ "${type}" != "swap" ]; then
		case "${mntpnt}" in
			/)
				fs_passno=1
				;;
			*)
				if is_nativefs "${type}"; then
					fs_passno=2
				else
					fs_passno=0
				fi
				;;
		esac
	else
		fs_passno=0
	fi

	if ${OPT_LABELS} || ${OPT_UUIDS}; then
		printf "%-40s %-20s %-20s %-20s %d %d\n\n" "${fs_spec}" \
		       "${fs_file}" "${fs_vfstype}" "${fs_mntops}" \
		       "${fs_freq}" "${fs_passno}"
	else
		printf "%-20s %-20s %-20s %-20s %d %d\n\n" "${fs_spec}" \
		       "${fs_file}" "${fs_vfstype}" "${fs_mntops}" \
		       "${fs_freq}" "${fs_passno}"
	fi
}

#
# enumerate partitions to be added to fstab
#
scan_partitions()
{
	local name part mnt
	local path base disk
	path="${1}"
	base="${2}"
	disk="${3}"

	for p in ${path}/${base}*; do
		[ -d "${p}" ] || continue
		name=${p##*/}

		unset ID_FS_USAGE ID_FS_TYPE ID_FS_VERSION \
		      ID_FS_UUID ID_FS_UUID_ENC \
		      ID_FS_LABEL ID_FS_LABEL_ENC ID_FS_LABEL_SAFE \
		      mnt


		eval "$(disk_env ${name} | grep -e '^ID_FS_USAGE=' \
						-e '^ID_FS_TYPE=' \
						-e '^ID_FS_VERSION=' \
						-e '^ID_FS_UUID=' \
						-e '^ID_FS_UUID_ENC=' \
						-e '^ID_FS_LABEL=' \
						-e '^ID_FS_LABEL_ENC=' \
						-e '^ID_FS_LABEL_SAFE=')"

		debugstr "sysfs path: ${p}"
		debugstr "ID_FS_USAGE=${ID_FS_USAGE}"
		debugstr "ID_FS_TYPE=${ID_FS_TYPE}"
		debugstr "ID_FS_VERSION=${ID_FS_VERSION}"
		debugstr "ID_FS_UUID=${ID_FS_UUID}"
		debugstr "ID_FS_UUID_ENC=${ID_FS_UUID_ENC}"
		debugstr "ID_FS_LABEL=${ID_FS_LABEL}"
		debugstr "ID_FS_LABEL_ENC=${ID_FS_LABEL_ENC}"
		debugstr "ID_FS_LABEL_SAFE=${ID_FS_LABEL_SAFE}"

		if [ "${ID_FS_USAGE}" = "filesystem" ]; then
			if grep -s -q "^/dev/${name}" /etc/mtab; then
				mnt="$(sed -n "s%^/dev/${name} \([^[:space:]]\+\).*%\1%p" /etc/mtab)"
			fi
		elif [ "${ID_FS_TYPE}" = "swap" ]; then
			mnt="none"
		else
			debugstr "partition not a valid filesystem"
			continue
		fi

		print_fsentry "${name}" "${mnt}" "${ID_FS_TYPE}" \
			      "${ID_FS_UUID_ENC}" "${ID_FS_LABEL_SAFE}"

		mkmntpnt "${fs_file}"
	done
}

#
# scan for block devices
#
scan_disks()
{
	local disk name
	disk=1
	
	for p in /sys/block/*; do
		[ -d "${p}" ] || continue
		name="${p#/sys/block/}"

		unset ID_BUS ID_TYPE

		eval "$(disk_env ${name} | grep -e '^ID_BUS=' \
						-e '^ID_TYPE=')"

		debugstr "sysfs path: ${p}"
		debugstr "ID_BUS=${ID_BUS}"
		debugstr "ID_TYPE=${ID_TYPE}"

		if [ "${ID_TYPE}" != disk ]; then
			debugstr "device is not of disk type, skip"
			continue
		elif [ "${ID_BUS}" = "usb" ]; then
			debugstr "device is on usb bus, skip"
			continue
		elif is_removable "${p}"; then
			debugstr "device has removable attribute, skip"
			continue
		fi

		debugstr "device is a disk, count: ${disk}"
		scan_partitions "${p}" "${name}" "${disk}"
		disk=$((disk + 1))
	done
}

#
# scan for cdom devices to add to fstab
# NOTE: /dev/cdrom* are persistent symlinks managed by
#   /etc/udev/rules.d/z25_persistent-cd.rules
#
scan_cdroms()
{
	local fs_spec fs_file fs_vfstype fs_mntops fs_freq fs_passno
	fs_vfstype="udf,iso9660"
	fs_mntops="user,noauto"
	fs_freq=0
	fs_passno=0

	for c in /dev/cdrom*; do
		[ -L "${c}" ] || continue
		fs_spec="${c}"
		fs_file="/media/${c#/dev/}"
		
		printf "%-20s %-20s %-20s %-20s %d %d\n\n" "${fs_spec}" "${fs_file}" \
		       "${fs_vfstype}" "${fs_mntops}" "${fs_freq}" "${fs_passno}"
		
		mkmntpnt "${fs_file}"
	done
}

#
# scan for floppy devices to add to fstab
#
scan_floppies()
{
	local fs_spec fs_file fs_vfstype fs_mntops fs_freq fs_passno
	fs_vfstype="auto"
	fs_mntops="rw,user,noauto"
	fs_freq=0
	fs_passno=0

	for f in /dev/fd*; do
		[ -b "${f}" ] || continue
		fs_spec="${f}"
		fs_file="/media/${f#/dev/}"
		
		printf "%-20s %-20s %-20s %-20s %d %d\n\n" "${fs_spec}" "${fs_file}"  \
		       "${fs_vfstype}" "${fs_mntops}" "${fs_freq}" "${fs_passno}"
		
		mkmntpnt "${fs_file}"
	done
}

scan_disks
scan_cdroms
scan_floppies
