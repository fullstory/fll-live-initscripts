#!/bin/sh

OPT_DEBUG=:
OPT_UUIDS=:
OPT_LABELS=false
OPT_AUTOMNT=false
OPT_MKMNTPNT=false

#
# future proof udev info query tool command
#
if which udevadm >/dev/null; then
	udev_info() { udevadm info --query="${1}" --name="${2}"; }
else
	udev_info() { udevinfo --query="${1}" --name="${2}"; }
fi

#
# output udev enironment information for a block device
#
disk_env()
{
	[ -b "/dev/${1}" ] || return 1

	udev_info env "/dev/${1}" 2>/dev/null
}

#
# resolve canonical device node
#
resolve_device()
{
	local name

	case "${1}" in
		LABEL=*|UUID=*)
			name="$(findfs ${1})"
			;;
		/dev/disk/by-*)
			name="$(readlink -f ${1})"
			;;
		/dev/*)
			name="${1}"
			;;
	esac

	if [ -b "${name}" ]; then
		echo "${name}"
	fi
}

#
# test block device "removable" attribute
#
is_removable()
{
	! grep -s -q '^0$' "${1}/removable"
}

#
# return true for Linux native filesystems
#
is_nativefs()
{
	case "${1}" in
		ext[2-4]|reiser*|[jx]fs|swap)
			return 0
			;;
		*)
			return 1
			;;
	esac
}

#
# conditionally make mount point directories
#
mkmntpnt()
{
	if "${OPT_MKMNTPNT}"; then
		mkdir -p "${1}"
	fi
}

#
# output debug starting with 'D:' to stderr
#
debugstr()
{
	if "${OPT_DEBUG}"; then
		echo "D: ${@}" >/dev/stderr
	fi
}

#
# print fstab entry for a filesystem
#
print_fsentry()
{
	local fs_spec fs_file fs_vfstype fs_mntops
	local disk part name type uuid label
	disk="${1}"
	part="${2}"
	name="${3}"
	type="${4}"
	uuid="${5}"
	label="${6}"

	#
	# fs_spec - first field describes the block special device or remote
	#           filesystem to be mounted
	#
	if "${OPT_LABELS}" && [ -L "/dev/disk/by-label/${label}" ]; then
		if is_nativefs "${type}"; then
			fs_spec="LABEL=${label}"
		else
			fs_spec="/dev/disk/by-label/${label}"
		fi
	elif "${OPT_UUIDS}" && [ -L "/dev/disk/by-uuid/${uuid}" ]; then
		if is_nativefs "${type}"; then
			fs_spec="UUID=${uuid}"
		else
			fs_spec="/dev/disk/by-uuid/${uuid}"
		fi
	else
		fs_spec="/dev/${name}"
	fi

	#
	# fs_file - second field describes the mount point for the filesystem
	#
	if [ "${type}" = "swap" ]; then
		fs_file="none"
	else
		case "${name}" in
			dm-*)
				fs_file="/media/${name}"
				;;
			*)
				fs_file="/media/disk${disk}part${part}"
				;;
		esac
	fi

	#
	# fs_vfstype - third field describes the type of the filesystem
	#
	fs_vfstype="${type}"

	#
	# fs_mntops - fourth field describes the mount options associated with
	#             the filesystem
	#
	if "${OPT_AUTOMNT}"; then
		fs_mntops="auto"
	else
		fs_mntops="noauto"
	fi

	case "${type}" in
		ntfs)
			fs_mntops="${fs_mntops},ro,dmask=0022,fmask=0133,nls=utf8"
			;;
		msdos)
			fs_mntops="${fs_mntops},quiet,umask=000,iocharset=utf8"
			;;
		vfat)
			fs_mntops="${fs_mntops},shortname=lower,quiet,umask=000,utf8"
			;;
		swap)
			fs_mntops="sw"
			;;
		*)
			if is_nativefs "${type}"; then
				fs_mntops="${fs_mntops},users,exec,noatime"
			else
				fs_mntops="${fs_mntops},defaults"
			fi
			;;
	esac

	#
	# fs_freq - fifth field is used for these filesystems by the dump(8)
	#           command
	#
	fs_freq=0

	#
	# fs_passno - sizth field is used by the fsck(8) program to determine
	#             the order in which filesystem checks are done at bootup
	#
	fs_passno=0

	printf "%s\t%s\t%s\t%s\t%d %d\n\n" "${fs_spec}" "${fs_file}" \
	       "${fs_vfstype}" "${fs_mntops}" "${fs_freq}" "${fs_passno}"
}

#
# enumerate partitions to be added to fstab
#
scan_partitions()
{
	local path base disk name part retv
	path="${1}"
	base="${2}"
	disk="${3}"
	retv=1

	for p in ${path}/${base}*; do
		[ -d "${p}" ] || continue
		name=${p##*/}

		unset ID_FS_USAGE ID_FS_TYPE ID_FS_VERSION \
		      ID_FS_UUID ID_FS_UUID_ENC \
		      ID_FS_LABEL ID_FS_LABEL_ENC ID_FS_LABEL_SAFE


		eval "$(disk_env ${name})"

		debugstr "sysfs path: ${p}"
		debugstr "ID_FS_USAGE=${ID_FS_USAGE}"
		debugstr "ID_FS_TYPE=${ID_FS_TYPE}"
		debugstr "ID_FS_VERSION=${ID_FS_VERSION}"
		debugstr "ID_FS_UUID=${ID_FS_UUID}"
		debugstr "ID_FS_UUID_ENC=${ID_FS_UUID_ENC}"
		debugstr "ID_FS_LABEL=${ID_FS_LABEL}"
		debugstr "ID_FS_LABEL_ENC=${ID_FS_LABEL_ENC}"
		debugstr "ID_FS_LABEL_SAFE=${ID_FS_LABEL_SAFE}"

		if [ "${ID_FS_USAGE}" != "filesystem" ] && \
		   [ "${ID_FS_TYPE}" != "swap" ]; then
			debugstr "partition not a valid filesystem"
			continue
		fi

		# calculate partition number
		if [ ${#name} -gt ${#base} ]; then
			part=${name#${base}}
			part=${part#-}
			case "${part}" in
				*[!0-9]*)
					debugstr "invalid part number: ${part}"
					continue
					;;
			esac
		else
			debugstr "error calculating part number"
			continue
		fi

		# disk has yielded at least one volume
		retv=0

		print_fsentry "${disk}" "${part}" "${name}" "${ID_FS_TYPE}" \
			      "${ID_FS_UUID_ENC}" "${ID_FS_LABEL_SAFE}"
	done

	return "${retv}"
}

#
# scan for block devices
#
scan_disks()
{
	local disk name
	disk=1
	
	for p in /sys/block/*; do
		[ -d "${p}" ] || continue
		name="${p#/sys/block/}"

		unset ID_BUS ID_TYPE

		eval "$(disk_env ${name})"

		debugstr "sysfs path: ${p}"
		debugstr "ID_BUS=${ID_BUS}"
		debugstr "ID_TYPE=${ID_TYPE}"

		if [ "${ID_TYPE}" != disk ]; then
			debugstr "device is not of disk type, skip"
			continue
		elif [ "${ID_BUS}" = "usb" ]; then
			debugstr "device is on usb bus, skip"
			continue
		elif is_removable "${p}"; then
			debugstr "device has removable attribute, skip"
			continue
		fi

		debugstr "device is a disk, count: ${disk}"
		
		scan_partitions "${p}" "${name}" "${disk}"
		if [ "${?}" -eq 0 ]; then
			disk=$((disk + 1))
		fi
	done
}

#
# scan for cdom devices to add to fstab
# NOTE: /dev/cdrom* are persistent symlinks managed by
#   /etc/udev/rules.d/z25_persistent-cd.rules
#
scan_cdroms()
{
	for c in /dev/cdrom*; do
		[ -L "${c}" ] || continue
		printf "%s\t/media/%s\tudf,iso9660\tuser,noauto\t 0 0\n" \
			"${c}" "${c#/dev/}"
		mkmntpnt "${c#/dev/}"
	done
}

#
# scan for floppy devices to add to fstab
#
scan_floppies()
{
	for f in /dev/fd*; do
		[ -b "${f}" ] || continue
		printf "%s\t/media/%s\tauto\trw,user,noauto\t 0 0\n" \
			"${f}" "${f#/dev/}"
		mkmntpnt "${f#/dev/}"
	done
}

scan_disks
scan_cdroms
scan_floppies
