#!/bin/sh
#
# Copyright: (C) 2008 Kel Modderman <kel@otaku42.de>
# License:   GPLv2
#

OPT_AUTOMNT=false
OPT_DEBUG=false
OPT_LABELS=false
OPT_LIVEONLY=false
OPT_MKMNTPNT=false
OPT_NOMNTPNT=false
OPT_NOSWAP=false
OPT_UUIDS=false
OPT_WANTED=false

# Default output file is stdout
OPT_FILE=/dev/stdout

OPT_CLIARGS=$(getopt --options adf:lmnsuw: \
		  --longoptions auto,debug,file:,labels,mkdir,nomnt,swapless,uuids,wanted: \
		  --name "${0}" -- "${@}")

if [ "${?}" -eq 0 ]; then
	eval set -- "${OPT_CLIARGS}"
else
	echo "getopt terminated abnormally" >/dev/stderr
	exit 255
fi

while :; do
	case "${1}" in
		-a|--auto)
			OPT_AUTOMNT=:
			;;
		-d|--debug)
			if ${OPT_DEBUG}; then
				set -x
			else
				OPT_DEBUG=:
			fi
			;;
		-f|--file)
			shift
			OPT_FILE="${1}"
			;;
		-l|--labels)
			OPT_LABELS=:
			;;
		-m|--mkdir)
			OPT_MKMNTPNT=:
			;;
		-n|--nomnt)
			OPT_NOMNTPNT=:
			;;
		-s|--swapless)
			OPT_NOSWAP=:
			;;
		-u|--uuids)
			OPT_UUIDS=:
			;;
		-w|--wanted)
			OPT_WANTED=:
			shift
			OPT_WANTED_DEVICES="${OPT_WANTED_DEVICES} ${1}"
			;;
		--)
			shift
			break
			;;
	esac
	shift
done

#
# output debug starting with 'D:' to stderr
#
dbg()
{
	${OPT_DEBUG} && echo "D: ${@}" >/dev/stderr
}

#
# output warning starting with 'W:' to stderr
#
warn()
{
	echo "W: ${@}" >/dev/stderr
}

#
# future proof udev info query tool command
#
if which udevadm >/dev/null; then
	udev_info()
	{
		udevadm info --query="${1}" --name="${2}"
	}
	udev_blkdev_trigger()
	{
		udevadm trigger --subsystem-match=block
		udevadm settle --timeout=30
	}
else
	udev_info()
	{
		udevinfo --query="${1}" --name="${2}"
	}
	udev_blkdev_trigger()
	{
		udevtrigger --subsystem-match=block
		udevsettle --timeout=30
	}
fi

if [ "$(id -u)" -eq 0 ]; then
	udev_volid()
	{
		/lib/udev/vol_id "--${1}" "${2}"
	}
else
	udev_volid()
	{
		warn "must be root user to execute vol_id"
		return
	}
fi

#
# output udev enironment information for a block device
#
disk_env()
{
	[ -b "/dev/${1}" ] && udev_info env "/dev/${1}" 2>/dev/null
}

#
# output udev symlink information for a block device
#
disk_symlinks()
{
	[ -b "/dev/${1}" ] && udev_info symlink "/dev/${1}" 2>/dev/null
}

#
# test block device "removable" attribute
#
is_removable()
{
	! grep -s -q '^0$' "${1}/removable"
}

#
# return true for Linux native filesystems
#
is_nativefs()
{
	case "${1}" in
		ext[2-4]|reiser*|[jx]fs|swap)
			return 0
			;;
		*)
			return 1
			;;
	esac
}

#
# check for mounted device and return mount point
#
is_mounted()
{
	local mntpnt

	for d in ${@}; do
		mntpnt=$(sed -n "s%^/dev/${d} \([^[:space:]]\+\).*%\1%p" /proc/mounts | head -n1)
		if [ "${mntpnt}" ]; then
			echo "${mntpnt}"
			break
		fi
	done
}

#
# we really want this device to be in fstab, even if it doesn't usually qualify
# to be there (eg. usb disk)
#
is_wanted()
{
	local name node
	name="${1}"
	node="/dev/${1}"

	if ! ${OPT_WANTED}; then
		return 1
	fi

	for device in ${OPT_WANTED_DEVICES}; do
		[ "${name}" = "${device}" ] && return 0
		[ "${node}" = "${device}" ] && return 0
	done

	return 1
}

#
# conditionally make mount point directories
#
mkmntpnt()
{
	${OPT_MKMNTPNT} && mkdir -p "${1}"
}

#
# private function to control formatting of printed output
#
_printf_mntent()
{
	if ${OPT_UUIDS} || [ "${#1}" -ge 20 ]; then
		printf "%-45s %-30s %-15s %-40s %-6s %s\n\n" \
		       "${1}" "${2}" "${3}" "${4}" "${5}" "${6}" >>"${OPT_FILE}"
	else
		printf "%-20s %-30s %-15s %-40s %-6s %s\n\n" \
		       "${1}" "${2}" "${3}" "${4}" "${5}" "${6}" >>"${OPT_FILE}"
	fi
}

#
# print fstab entry for a filesystem
#
print_fsentry()
{
	local fs_spec fs_file fs_vfstype fs_mntops fs_freq fs_passno
	local name type symlinks label uuid mounted part
	name="${1}"
	type="${2}"
	mounted=false

	case "${name}" in
		mapper/*)
			type=$(udev_volid type /dev/${name})
			label=$(udev_volid label /dev/${name})
			uuid=$(udev_volid uuid /dev/${name})
			;;
		*)
			symlinks=$(disk_symlinks ${name})

			for s in ${symlinks}; do
				[ -L "/dev/${s}" ] || continue
				dbg "${s}"

				case "${s}" in
					disk/by-label/*)
						label="${s##*/}"
						;;
					disk/by-uuid/*)
						uuid="${s##*/}"
						;;
				esac
			done
			;;
	esac

	#
	# fs_spec - first field describes the block special device or remote
	#           filesystem to be mounted
	#
	if ${OPT_LABELS} && [ "${label}" ]; then
		if is_nativefs "${type}"; then
			fs_spec="LABEL=${label}"
		else
			fs_spec="/dev/disk/by-label/${label}"
		fi
	elif ${OPT_UUIDS} && [ "${uuid}" ]; then
		if is_nativefs "${type}"; then
			fs_spec="UUID=${uuid}"
		else
			fs_spec="/dev/disk/by-uuid/${uuid}"
		fi
	else
		fs_spec="/dev/${name}"
	fi

	#
	# fs_file - second field describes the mount point for the filesystem
	#
	if ! ${OPT_NOMNTPNT}; then
		fs_file=$(is_mounted ${name} ${symlinks})
	fi

	if [ "${fs_file}" ]; then
		dbg "${name} is mounted on ${fs_file}"
		mounted=:
	elif [ "${type}" = "swap" ]; then
		fs_file="none"

		if ${OPT_NOSWAP}; then
			return
		fi
	else
		case "${name}" in
			mapper/*)
				fs_file="/media/${name#mapper/}"
				;;
			*)
				part=$(echo ${name} | egrep -o '[[:digit:]]+$')
				
				if [ "${part}" ]; then
					fs_file="/media/disk${disk}part${part}"
				else
					dbg "partition index invalid"
					continue
				fi
				;;
		esac
	fi

	#
	# fs_vfstype - third field describes the type of the filesystem
	#
	if [ -z "${type}" ]; then
		warn "could not determine filesystem type of ${name}"
		return
	fi
	fs_vfstype="${type}"

	#
	# fs_mntops - fourth field describes the mount options associated with
	#             the filesystem
	#
	if ${OPT_AUTOMNT}; then
		fs_mntops="auto,users"
	else
		fs_mntops="noauto,users"
	fi

	case "${type}" in
		ntfs)
			fs_mntops="${fs_mntops},ro,dmask=0022,fmask=0133,nls=utf8"
			;;
		msdos)
			fs_mntops="${fs_mntops},quiet,umask=000,iocharset=utf8"
			;;
		vfat)
			fs_mntops="${fs_mntops},quiet,umask=000,shortname=lower"
			;;
		swap)
			fs_mntops="sw"
			;;
		*)
			if is_nativefs "${type}"; then
				if ${mounted}; then
					case "${fs_file}" in
						/media/*)
							fs_mntops="${fs_mntops},exec,noatime"
							;;
						*)
							fs_mntops="defaults,noatime"
							;;
					esac
				else
					fs_mntops="${fs_mntops},exec,noatime"
				fi
			else
				warn "unhandled filesystem type: ${type}"
				return
			fi
			;;
	esac

	#
	# fs_freq - fifth field is used for these filesystems by the dump(8)
	#           command
	#
	fs_freq=0

	#
	# fs_passno - sizth field is used by the fsck(8) program to determine
	#             the order in which filesystem checks are done at bootup
	#
	if ${mounted} && [ "${type}" != "swap" ]; then
		case "${fs_file}" in
			/)
				fs_passno=1
				;;
			*)
				if is_nativefs "${type}"; then
					fs_passno=2
				else
					fs_passno=0
				fi
				;;
		esac
	else
		fs_passno=0
	fi

	_printf_mntent "${fs_spec}" "${fs_file}" "${fs_vfstype}" \
		       "${fs_mntops}" "  ${fs_freq}" "  ${fs_passno}"

	mkmntpnt "${fs_file}"
}

#
# enumerate partitions to be added to fstab
#
scan_partitions()
{
	local name part mntpnt
	local path base disk
	path="${1}"
	base="${2}"
	disk="${3}"

	for p in ${path}/${base}*; do
		[ -d "${p}" ] || continue
		name=${p##*/}

		unset ID_FS_TYPE ID_FS_USAGE

		eval "$(disk_env ${name} | grep -e '^ID_FS_TYPE=' \
						-e '^ID_FS_USAGE=')"

		dbg "sysfs path: ${p}"
		dbg "ID_FS_TYPE=${ID_FS_TYPE} ID_FS_USAGE=${ID_FS_USAGE}"

		if [ "${ID_FS_USAGE}" != "filesystem" ] && \
		   [ "${ID_FS_TYPE}" != "swap" ]; then
			dbg "partition not a valid filesystem: ${name}"
			continue
		fi

		print_fsentry "${name}" "${ID_FS_TYPE}"
	done
}

#
# scan for block devices
#
scan_disks()
{
	local disk name
	disk=1

	if [ "$(id -u)" -eq 0 ]; then
		udev_blkdev_trigger
	fi

	for p in /sys/block/*; do
		[ -d "${p}" ] || continue
		name="${p#/sys/block/}"

		unset ID_BUS ID_TYPE

		eval "$(disk_env ${name} | grep -e '^ID_BUS=' \
						-e '^ID_TYPE=')"

		dbg "sysfs path: ${p}"
		dbg "ID_BUS=${ID_BUS} ID_TYPE=${ID_TYPE}"

		if [ "${ID_TYPE}" != disk ]; then
			dbg "device is not of disk type, skip"
			continue
		elif ! is_wanted "${name}"; then
			if [ "${ID_BUS}" = "usb" ]; then
				dbg "device is on usb bus, skip"
				continue
			elif is_removable "${p}"; then
				dbg "device has removable attribute, skip"
				continue
			fi
		fi

		case "${name}" in
			[sh]d*)
				dbg "device is a disk, count: ${disk}"
				scan_partitions "${p}" "${name}" "${disk}"
				disk=$((disk + 1))
				;;
			dm-[0-9]*)
				dbg "device is a virtual block device"
				;;
			*)
				warn "disk device unhandled: ${name} (${p})"
				;;
		esac
	done
}

#
# scan for virtual (device mapper) block devices
#
scan_virtual_disks()
{
	local name

	for b in /dev/mapper/*; do
		[ -b "${b}" ] || continue
		name="${b#/dev/}"

		print_fsentry "${name}"
	done
}

#
# scan for cdom devices to add to fstab
# NOTE: /dev/cdrom* are persistent symlinks managed by
#   /etc/udev/rules.d/z25_persistent-cd.rules
#
scan_cdroms()
{
	local fs_spec fs_file fs_vfstype fs_mntops fs_freq fs_passno
	fs_vfstype="udf,iso9660"
	fs_mntops="ro,users,noauto"
	fs_freq=0
	fs_passno=0

	for c in /dev/cdrom*; do
		[ -L "${c}" ] || continue

		fs_spec="${c}"
		fs_file="/media/${c#/dev/}"

		_printf_mntent "${fs_spec}" "${fs_file}" "${fs_vfstype}" \
			       "${fs_mntops}" "  ${fs_freq}" "  ${fs_passno}"

		mkmntpnt "${fs_file}"
	done
}

#
# scan for floppy devices to add to fstab
#
scan_floppies()
{
	local fs_spec fs_file fs_vfstype fs_mntops fs_freq fs_passno
	fs_vfstype="auto"
	fs_mntops="rw,users,noauto"
	fs_freq=0
	fs_passno=0

	for f in /dev/fd*; do
		[ -b "${f}" ] || continue

		fs_spec="${f}"
		fs_file="/media/${f#/dev/}"

		_printf_mntent "${fs_spec}" "${fs_file}" "${fs_vfstype}" \
			       "${fs_mntops}" "  ${fs_freq}" "  ${fs_passno}"

		mkmntpnt "${fs_file}"
	done
}

fstab_header()
{
	cat >"${OPT_FILE}" <<EOF
# /etc/fstab - static information about the filesystems - fstab(5)
#
# /etc/fstab is only read by programs, and not written; it is the duty of the
# system administrator to properly maintain this file.
#
# Instead  of giving the device explicitly, one may indicate the filesystem
# that is to be mounted by its UUID or VOLUME label. This will make the
# system more robust: adding or removing a disk changes the disk device name
# but not the filesystem UUID or VOLUME label.
#
EOF

	_printf_mntent "# <filesystem>" "<mount point>" "<fstype>" \
		       "<mount options>" "<dump>" "<pass>"
}

fstab_header
scan_disks
scan_virtual_disks
scan_cdroms
scan_floppies
