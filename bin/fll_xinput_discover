#!/usr/bin/perl
#
# Copyright (C) 2007 Kel Modderman <kel@otaku42.de>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this package; if not, write to the Free Software 
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, 
# MA 02110-1301, USA.
#
# On Debian GNU/Linux systems, the text of the GPL license can be
# found in /usr/share/common-licenses/GPL.

use warnings;
use strict;

use Switch 'Perl6';
use Getopt::Long;

my $debug;
my $hwinfo;

GetOptions(
	'debug' => \$debug,
	'hwinfo' => \$hwinfo,
);

if ($debug) {
	require Data::Dumper;
	import Data::Dumper;
	print "Debugging...\n";
}

sub dbg {
	return unless $debug;
	
	for my $data (@_) {
		next unless $data;

		if (ref $data) {
			print STDERR "DBG: " . Dumper($data);
		}
		else {
			print STDERR "DBG: $data\n";
		}
	}
}

my %input;
my @input_devices;
my ($name, $device, $phys, $mouse, $corepointer);

if (-f '/proc/bus/input/devices') {
	dbg "using primary detection method: /proc/bus/input/devices";
	open(INPUT, '<', '/proc/bus/input/devices')
		or die "Unable to read '/proc/bus/input/devices': $!\n";
	PI: while (<INPUT>) {
		chomp;
		dbg $_;
		
		unless (/^./) {
			($name, $device, $phys, $mouse) = ();
			next;
		}
		
		my ($key, $val) = split '=';
		($key and $val) or next;

		$key =~ s/^\w:\s+//;

		given (lc($key)) { 
			when 'name' {
				$name = $val;
			}
			when 'handlers' {
				$val =~ /mouse(\d+)/ and $mouse = $1;
			}
			when 'phys' {
				$phys = $val;
			}
		}

		next unless (defined $mouse and $name and $phys);

		$device = '/dev/input/mice';

		given ($phys) {
			when m/^isa/ {
				given ($name) {
					when m/SynPS\/2/ {
						$phys = 'synaptics';
						$device = '/dev/psaux';
					}
					when m/AlpsPS\/2/ {
						$phys = 'alps';
						$device = '/dev/psaux';
					}
					default {
						$phys = 'ps2';
					}
				}
			}
			when m/^usb/ { 
				$phys = 'usb';
			}
		}

		dbg "'name' => $name, 'type' => $phys, 'device' => $device";
		
		$input{$mouse} = {
			'name' => $name,
			'type' => $phys,
			'device' => $device
		};

		($name, $phys, $mouse) = ();
	}
	close(INPUT);

	dbg \%input;
}

# set $mouse to current input device count
$mouse = keys %input ? keys %input : 0;
dbg "mouse count: $mouse";

# fallback mouse detection via hwinfo - probe for serial mouse when
# no other devices detected above via /proc/bus/input/devices
if (($hwinfo || not keys %input) and -x '/usr/sbin/hwinfo') {
	dbg "using alternative detection method: hwinfo --mouse --short";
	open(HWINFO, '-|', '/usr/sbin/hwinfo --mouse --short')
		or die("Unable to execute hwinfo --mouse: $!\n");
	HW: while (<HWINFO>) {
		chomp;
		dbg $_;

		($name, $device, $phys) = ();
		
		if (m|^\s*(/dev/[^\s]+)\s+(.+)$|) {
			$device = $1;
			$name = "\"$2\"";
			if ($name and $device) {
				if ($device =~ m|/dev/tty.+\d$|) {
					$phys = 'serial';
				}
				else {
					given ($name) {
						when m/SynPS\/2/ {
							$phys = 'synaptics';
							$device = '/dev/psaux';
						}
						when m/AlpsPS\/2/ {
							$phys = 'alps';
							$device = '/dev/psaux';
						}
						default {
							# xserver will autoconfigure usb/ps2 mice
							# we cannot differentiate them here anyway
							dbg "Ignoring $name";
							next HW;
						}
					}
				}

				dbg "'name' => $name, 'type' => $phys, 'device' => $device";

				$input{$mouse} = {
					'name' => $name,
					'type' => $phys,
					'device' => $device
				};

				$mouse++;
			}
		}
	}
	close(HWINFO);

	dbg \%input;
}			

for my $key (sort keys %input) {
	push @input_devices, '--input';
	for ('name', 'type', 'device') {
		push @input_devices, $_ . '=' . $input{$key}->{$_},
	}
	# if input device is not removable, and no corepointer has been
	# assigned yet, do so. Everything else -> SendCoreEvents
	if ($input{$key}->{'type'} ne 'usb' and not $corepointer) {
		push @input_devices, 'corepointer=CorePointer' and $corepointer++;
	}
	else {
		push @input_devices, 'corepointer=SendCoreEvents';
	}
}

print "XINPUT='@input_devices'\n";
