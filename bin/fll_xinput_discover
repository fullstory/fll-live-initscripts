#!/usr/bin/perl

use warnings;
use strict;

use Switch 'Perl6';
use Getopt::Long;

my $debug;
my $serial;

GetOptions(
	'debug' => \$debug,
	'serial' => \$serial,
);

if ($debug) {
	require Data::Dumper;
	import Data::Dumper;
	print "Debugging...\n";
}

sub dbg {
	return unless $debug;
	
	for my $data (@_) {
		next unless $data;

		if (ref $data) {
			print STDERR "DBG: " . Dumper($data);
		}
		else {
			print STDERR "DBG: $data\n";
		}
	}
}

my %input;
my @input_devices;
my ($name, $device, $phys, $mouse);

if (-f '/proc/bus/input/devices' and not $serial) {
	dbg "using primary detection method: /proc/bus/input/devices";
	open(INPUT, '<', '/proc/bus/input/devices')
		or die "Unable to read '/proc/bus/input/devices': $!\n";
	PI: while (<INPUT>) {
		chomp;
		dbg $_;
		
		unless (/^./) {
			($name, $device, $phys, $mouse) = ();
			next;
		}
		
		my ($key, $val) = split '=';
		($key and $val) or next;

		$key =~ s/^\w:\s+//;

		given (lc($key)) { 
			when 'name' {
				$name = $val;
			}
			when 'handlers' {
				$val =~ /mouse(\d+)/ and $mouse = $1;
			}
			when 'phys' {
				$phys = $val;
			}
		}

		next unless (defined $mouse and $name and $phys);

		$device = '/dev/input/mice';

		given ($phys) {
			when m/^isa/ {
				given ($name) {
					when m/SynPS\/2/ {
						$phys = 'synaptics';
						$device = '/dev/psaux';
					}
					when m/AlpsPS\/2/ {
						$phys = 'alps';
						$device = '/dev/psaux';
					}
					default {
						$phys = 'ps2';
					}
				}
			}
			when m/^usb/ { 
				$phys = 'usb';
			}
		}

		dbg "'name' => $name, 'type' => $phys, 'device' => $device";
		
		$input{$mouse} = {
			'name' => $name,
			'type' => $phys,
			'device' => $device
		};

		($name, $phys, $mouse) = ();
	}
	close(INPUT);

	dbg \%input;
}

# fallback mouse detection via hwinfo - probe for serial mouse when
# no other devices detected above via /proc/bus/input/devices
if (($serial || not keys %input) and -x '/usr/sbin/hwinfo') {
	dbg "using fallback detection method: hwinfo --mouse --short";
	open(HWINFO, '-|', '/usr/sbin/hwinfo --mouse --short')
		or die("Unable to execute hwinfo --mouse: $!\n");
	HW: while (<HWINFO>) {
		chomp;
		dbg $_;

		($name, $device, $phys) = ();
		
		if (m|^\s*(/dev/[^\s]+)\s+(.+)$|) {
			$device = $1;
			$name = "\"$2\"";
			if ($name and $device) {
				if ($device =~ m|/dev/tty.+\d$|) {
					$phys = 'serial';
				}
				else {
					given ($name) {
						when m/SynPS\/2/ {
							$phys = 'synaptics';
							$device = '/dev/psaux';
						}
						when m/AlpsPS\/2/ {
							$phys = 'alps';
							$device = '/dev/psaux';
						}
						default {
							# xserver will autoconfigure usb/ps2 mice
							# we cannot differentiate them here anyway
							dbg "Ignoring $name";
							next HW;
						}
					}
				}

				dbg "'name' => $name, 'type' => $phys, 'device' => $device";

				$mouse++;

				$input{$mouse} = {
					'name' => $name,
					'type' => $phys,
					'device' => $device
				};
			}
		}
	}
	close(HWINFO);

	dbg \%input;
}			

for my $key (sort keys %input) {
	if ($input{$key}->{'type'} =~ /^(ps2|usb)$/) {
		# xserver will autoconfigure usb/ps2 mice
		dbg "Ignoring " . $input{$key}->{'type'} . " mouse ($key), xserver will autoconfigure it...";
		next;
	}
	push @input_devices, '--input';
	for ('name', 'type', 'device') {
		push @input_devices, $_ . '=' . $input{$key}->{$_},
	}
}

print "XINPUT='@input_devices'\n";
