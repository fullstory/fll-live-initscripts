#!/usr/bin/perl
#
# Copyright (C) 2007 Kel Modderman <kel@otaku42.de>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this package; if not, write to the Free Software 
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, 
# MA 02110-1301, USA.
#
# On Debian GNU/Linux systems, the text of the GPL license can be
# found in /usr/share/common-licenses/GPL.

use warnings;
use strict;

use Switch 'Perl6';
use Getopt::Long;

my %input;
my @input_devices;
my ($name, $device, $phys, $mouse, $corepointer, $usb);

my $debug;
my $hwinfo;

GetOptions(
	'debug' => \$debug,
	'hwinfo' => \$hwinfo,
);

if ($debug) {
	require Data::Dumper;
	import Data::Dumper;
	print "Debugging...\n";
}

sub dbg {
	return unless $debug;
	
	for my $data (@_) {
		next unless $data;

		if (ref $data) {
			print STDERR "DBG: " . Dumper($data);
		}
		else {
			print STDERR "DBG: $data\n";
		}
	}
}

sub input_priority {
	my $retval = 0;
	
	my $a_type = $input{$a}->{'type'};
	my $b_type = $input{$b}->{'type'};
	
	dbg $a_type . " ($a) <=> ($b) " . $b_type;
	
	# input device sorting function assigns priority according to type:
	# alps/synaptics > ps/2 > serial > (?) > usb

	# preserve order of detection for input devices of same type
	if	($a_type eq $b_type)		{ $retval = $a <=> $b; }
	# usb is always last -> removable
	elsif	($a_type eq 'usb')		{ $retval++; }
	elsif	($b_type eq 'usb')		{ $retval--; }
	# top-down priority for the rest
	elsif	($a_type eq 'alps')		{ $retval--; }
	elsif	($b_type eq 'alps')		{ $retval++; }
	elsif	($a_type eq 'synaptics')	{ $retval--; }
	elsif	($b_type eq 'synaptics')	{ $retval++; }
	elsif	($a_type eq 'ps2')		{ $retval--; }
	elsif	($b_type eq 'ps2')		{ $retval++; }
	elsif	($a_type eq 'serial')		{ $retval--; }
	elsif	($b_type eq 'serial')		{ $retval++; }
	# preserve order of detection for unhandled input devices
	else					{ $retval = $a <=> $b; }

	dbg "retval: $retval";
	
	return $retval;
}

if (-f '/proc/bus/input/devices') {
	dbg "using primary detection method: /proc/bus/input/devices";
	open(INPUT, '<', '/proc/bus/input/devices')
		or die "Unable to read '/proc/bus/input/devices': $!\n";
	PI: while (<INPUT>) {
		chomp;
		dbg $_;

		#		
		#I: Bus=0011 Vendor=0002 Product=0005 Version=0000
		#N: Name="ImPS/2 Generic Wheel Mouse"
		#P: Phys=isa0060/serio1/input0
		#S: Sysfs=/class/input/input2
		#U: Uniq=
		#H: Handlers=mouse0 event2 ts0
		#B: EV=7
		#B: KEY=70000 0 0 0 0
		#B: REL=103
		#

		unless (/^./) {
			# each input device block is seperated by a blank line
			# clear these variables when we reach end of each block
			($name, $device, $phys, $mouse) = ();
			next;
		}
		
		my ($key, $val) = split '=';
		($key and $val) or next;

		$key =~ s/^\w:\s+//;

		given (lc($key)) { 
			when 'name' {
				$name = $val;
			}
			when 'handlers' {
				# the mice have already been counted
				$val =~ /mouse(\d+)/ and $mouse = $1;
			}
			when 'phys' {
				$phys = $val;
			}
		}

		next unless (defined $mouse and $name and $phys);

		# default mouse device, we still use /dev/psaux for touchpads
		$device = '/dev/input/mice';

		# redefine $phys to something fll_xorgconfig can use
		given ($phys) {
			when m/^isa/ {
				given ($name) {
					when m/SynPS\/2/ {
						$phys = 'synaptics';
						$device = '/dev/psaux';
					}
					when m/AlpsPS\/2/ {
						$phys = 'alps';
						$device = '/dev/psaux';
					}
					default {
						$phys = 'ps2';
					}
				}
			}
			when m/^usb/ { 
				$phys = 'usb';
			}
		}

		dbg "'name' => $name, 'type' => $phys, 'device' => $device";
		
		$input{$mouse} = {
			'name' => $name,
			'type' => $phys,
			'device' => $device
		};

		($name, $phys, $mouse) = ();
	}
	close(INPUT);

	dbg \%input;
}

# set $mouse to current input device count
$mouse = keys %input ? keys %input : 0;
dbg "mouse count: $mouse";

# fallback mouse detection via hwinfo - probe for serial mouse when
# no other devices detected above via /proc/bus/input/devices
# --hwinfo cli argument forces this detection method
if (($hwinfo || not keys %input) and -x '/usr/sbin/hwinfo') {
	dbg "using alternative detection method: hwinfo --mouse --short";
	open(HWINFO, '-|', '/usr/sbin/hwinfo --mouse --short')
		or die("Unable to execute hwinfo --mouse: $!\n");
	HW: while (<HWINFO>) {
		chomp;
		dbg $_;

		($name, $device, $phys) = ();
		
		if (m|^\s*(/dev/tty[^\s]+)\s+(.+)$|) {
			$device = $1;
			$name = "\"$2\"";
			$phys = 'serial';

			dbg "'name' => $name, 'type' => $phys, 'device' => $device";

			$input{$mouse} = {
				'name' => $name,
				'type' => $phys,
				'device' => $device
			};

			$mouse++;
		}
	}
	close(HWINFO);

	dbg \%input;
}			

for my $key (sort input_priority keys %input) {
	push @input_devices, '--input';
	for ('name', 'type', 'device') {
		push @input_devices, $_ . '=' . $input{$key}->{$_},
	}
	
	# elect a Core Pointer - USB device hotplugged later currently
	# will not work if we do this :/
	if ($corepointer) {
		push @input_devices, 'corepointer=SendCoreEvents';
	}
	else {
		push @input_devices, 'corepointer=CorePointer';
		$corepointer++;
	}
	$input{$key}->{'type'} eq 'usb' and $usb++;
}

# push a dummy USB mouse configuration if no usb mouse was detected
# workaround for CorePointer election...
if ($corepointer and not $usb) {
	push @input_devices, '--input', 'name="Generic USB Mouse"', 'type=usb',
		'device=/dev/input/mice', 'corepointer=SendCoreEvents';
}

print "XINPUT='@input_devices'\n";
