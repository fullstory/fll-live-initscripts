#!/usr/bin/perl

use warnings;
use strict;
use autouse 'Data::Dumper' => qw(Dumper);
use Cwd qw(getcwd realpath);
use Getopt::Long qw(:config bundling no_auto_abbrev);
use File::Path;
use Tie::File;

my $self = 'fll_src_uri';
my ($c, $d, $m, $o, $s, $t, $v);
$o = getcwd();

GetOptions(
	'c|cleanup'    => \$c,
	'd|debug'      => \$d,
	'm|manifest=s' => \$m,
	'o|output=s'   => \$o,
	's|sources=s'  => \$s,
	't|tar=s'      => \$t,
	'v|verbose'    => \$v,
);

sub dbg {
	return unless $d;

	# dump references, print everything else
	for (@_) {
		next unless defined;
		
		if (ref) {
			print STDERR Dumper($_);
		}
		else {
			print STDERR "$_\n";
		}
	}
}

sub cd {
	my $dir = shift;
	chdir($dir) or die "E: could not chdir($dir): $!\n";
}

sub sysexec {
	my $c = shift;

	# manage the process with fork and exec, allow SIGINT
	if (my $pid = fork) {
		local $SIG{'INT'} = sub {
			kill(9, $pid) and die "\nE: caught SIGINT: kill($pid)\n";
		};
		waitpid($pid, 0);
	}
	else {
		defined($pid) or die "E: cannot fork: $!\n";
		$v and print "V: $c\n";
		exec($c) or die "E: cannot exec: $!\n";
	}
}

if ($s and $m) {
	my ($slist, $plist) = (realpath($s), realpath($m));
	my (%done, %uris);

	# tie source list to an array, flock it
	my $s_o = tie(my @s, "Tie::File", $slist) or die "E: cannot open $slist for writing: $!\n";
	$s_o->flock;
	@s = ();

	# tie package list to array, flock it
	my $p_o = tie(my @p, "Tie::File", $plist) or die "E: cannot open $plist for writing: $!\n";
	$p_o->flock;
	@p = ();

	eval { require AptPkg::Cache };
	$@ and die "E: requires AptPkg::Cache (libapt-pkg-perl)\n";
	import AptPkg::Cache;

	eval { require AptPkg::Source };
	$@ and die "E: requires AptPkg::Source (libapt-pkg-perl)\n";
	import AptPkg::Source;

	my $cache  = new AptPkg::Cache;
	my $source = new AptPkg::Source;

	for my $name (sort keys %$cache) {
		# process installed packages
		my $state = $cache->{$name}->{'CurrentState'};
		next unless $state eq 'Installed';

		# get package version
		my $version = $cache->{$name}->{'CurrentVer'}->{'VerStr'};

		# format string, write to manifest
		$v and print "V: ${name}=${version}\n";
		push(@p, sprintf("%-55s%s", $name, $version));

		# get src uri's for $name
		for my $vers (@{ $source->{$name} }) {
			dbg $vers;

			# make ref to files list of highest available version
			my $files = $vers->{'Files'};

			# NB: this gets dsc URI for every available version
			# in archive. It cannot be reliably cmp'd with
			# version string of currently installed package for
			# _all_ packages, do not ask me why!
			for my $file (@$files) {
				dbg $file;

				# collect available dsc uri's only
				my $type = $file->{'Type'};
				next unless $type eq 'dsc';

				# add uri to hash
				my $auri = $file->{'ArchiveURI'};
				$uris{$auri}++;
				$done{$name}++;
			}
		}

		$done{$name} or warn "W: no source uri for $name\n";
	}

	# write src uri list to file
	push(@s, $_) for (sort keys %uris);
}
elsif ($s) {
	my ($slist, $tar, $out, $cleanup) = (realpath($s), $t, $o, $c);
	my %failed;

	-x '/usr/bin/dget' or die "E: dget is required (devscripts)\n";

	# tie source list to array
	my $s_o = tie(my @s, "Tie::File", $slist) or die "E: cannot open $slist for reading: $!\n";

	# create source directory
	eval { mkpath("$out/source", $v, 0755); };
	$@ and die "E: could not create $out: $@\n";

	# canonacalize path to source parent dir
	$out = realpath($out);

	# process the dsc list
	my $n = 0;
	while ($s[$n]) {
		my ($name, $dir);

		# determine name of package, get package prefix
		if ($s[$n] =~ m|.*/([^/]+)_.+\.dsc$|) {
			$name = $1;
			$dir = $name =~ /^lib/ ? substr($name, 0, 4) : substr($name, 0, 1);
		}
		else {
			die "E: failed to get name from dsc\n";
		}

		# create nice source tree layout
		eval { mkpath("$out/source/$dir/$name", $v, 0755); };
		$@ and die "E: could not create $out/source/$dir/$name: $@\n";

		# move to $name/$dir
		cd("$out/source/$dir/$name");

		# manage the dget process with fork and exec, allow SIGINT
		my $cmd = $v ? "/usr/bin/dget $s[$n]" : "/usr/bin/dget -q $s[$n]";
		sysexec($cmd);
	}
	continue {
		$n++;
	}

	# check for failures
	if (keys %failed) {
		warn "W: failed to dget: $_\n" for (sort keys %failed);
		die "E: some files failed to download, try again or fix manually\n";
	}

	cd($out);

	# make the source tarball
	if ($tar) {
		print "O: creating: $out/$tar\n";
		my $cmd = $v ? "tar -cvf $tar ./source" : "tar -cf $tar ./source";
		sysexec($cmd);
	}

	# cleanup
	if ($cleanup) {
		print "O: cleaning: $out/source\n";
		eval { rmtree("$out/source", $v, 1); };
		$@ and die "E: failed to rmtree($out/source): $!\n";
	}
}
else {
	print STDERR <<_EOF_
  This is $self, Copyright (C) 2007 Kel Modderman <kel\@otaku42.de>
  $self is licensed GPLv2, or any later version.

  Usage:

  To create a list of dsc URI's to fetch:
    $self -s|--source source.list -m|--manifest manifest.list

    Requires the libapt-pkg-perl package to be installed. $self will
    generate a list of dsc URI's in the source.list, and a list of installed
    packages in the manifest.list.

  To fetch dsc URI's from a list:
    $self -s|--source source.list -t|--tar name \
        [-o|--output /path/to/output] [-p|--preserve]
    
    $self will get the dsc URI's from the archive with dget(1) (from 
    devscripts package) and optionally put them in a tar archive. If no
    --output option is given, the source package tree will be formed in the
    current directory in a directory named 'source'. The tar file will be
    created in the output directory with the string given by the --tar option.
    The --cleanup option cleans up the source tree after the tarball has made.

_EOF_
	        ;
}
