#!/usr/bin/perl
#
# Copyright (C) 2007 - 2008 Kel Modderman <kel@otaku42.de>
#	    (C) 2007 Michiel de Boer <locsmif@kanotix.com>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this package; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
# MA 02110-1301, USA.
#
# On Debian GNU/Linux systems, the text of the GPL license can be
# found in /usr/share/common-licenses/GPL.
#

use warnings;
use strict;

#use Data::Dumper;
use Cwd qw(realpath);
use Getopt::Long qw(:config bundling no_auto_abbrev);

my (%init, @glob, $chroot);
my ($def, $dry, $frc, $lvl, $rem, $urcd);
my $etc     = '/etc';
my $found   = 0;
my $insserv = 0;

GetOptions(
	"c|chroot=s" => \$chroot,
	"d|defaults" => \$def,
	"f|force"    => \$frc,
	"l|runlevel" => \$lvl,
	"n|dryrun"   => \$dry,
	"r|remove"   => \$rem,
);

if ($chroot) {
	-d $chroot . '/etc/rcS.d/' or die "invalid chroot '$chroot': $!";
	$etc = $chroot . $etc;
}

if (realpath('/usr/sbin/update-rc.d') =~ /insserv$/) {
	$lvl or $insserv++;
}

for my $svc (@ARGV) {
	push(@glob, glob($etc . '/rc[0-6S].d/[KS][0-9][0-9]' . $svc));
}

@glob = glob($etc . '/rc[0-6S].d/[KS]*') unless @ARGV;

for (@glob) {
	next unless -L;
	next unless my ($rlev, $sk, $pri, $svc) = m|/rc(.)\.d/([SK])([0-9]{2})(.+)$|;
	push(@{ $init{$svc}{$sk}{$pri} }, $rlev);
}

#print Dumper \%init;

for my $svc (sort keys %init) {
	next if not -x $etc . '/init.d/' . $svc;

	my (@par, $prm);
	if ($insserv) {
		$urcd = 'insserv';
		$frc and push(@par, '--force');
		$dry and push(@par, '--dryrun');
		if ($rem) {
			push(@par, '--remove');
		}
		else {
			$def and push(@par, '--default');
		}
		push(@par, $svc);
	}
	else {
		$urcd = 'update-rc.d';
		$frc and push(@par, '-f');
		$dry and push(@par, '-n');

		my @s = keys %{ $init{$svc}{S} };
		my @k = keys %{ $init{$svc}{K} };

		if ($rem) {
			push(@par, $svc, 'remove');
		}
		elsif ( "@s" eq '20' and "@k" eq '20'
			and "@{ $init{$svc}{S}{20} }" eq '2 3 4 5'
			and "@{ $init{$svc}{K}{20} }" eq '0 1 6') {
			push(@par, $svc, 'defaults');
		}
		else {
			$prm .= "start $_ @{ $init{$svc}{S}{$_} } . " for (@s);
			$prm .= "stop $_ @{ $init{$svc}{K}{$_} } . "  for (@k);
			push(@par, $svc, $prm) if $prm;
		}
	}

	$found++;
	print "$urcd @par\n";
}

my $eval = (@ARGV and $found != @ARGV) ? 1 : 0;
exit($eval);
