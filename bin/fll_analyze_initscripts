#!/usr/bin/perl

# Warnings is much too loud, and i'm not the only one to
# complain about that, seen tutorials online that advise
# to only enable it when needed, for debugging. I agree.
#use warnings;
use strict;

#use Data::Dumper;
use Getopt::Long qw(:config bundling no_auto_abbrev);

# bundling is combining multiple short options together,
# no_auto_abbrev makes sure the error messages never
# abbreviate the parameter that was unknown.

# Declare all variables used in main here for oversight,
# except loop variables, because they don't persist.
# Variables start with undefined values, which evaluates
# to "" in scalar context.
my %info = ();
my (@glob, @k, @par, @s);
my ($count, $chroot, $pri, $prm, $sk, $svc, $rlev);
my ($doit, $found, $frc, $rem) = (0, 0, 0, 0);
my $urcd = "update-rc.d";

my $res = GetOptions(
	"a|apply"    => sub { $doit++; },
	"f|force"    => \$frc,
	"r|remove"   => sub { $rem++; $frc++; },
	"c|chroot=s" => \$chroot
);

-d $chroot . "/etc/rcS.d/" or die "invalid chroot '$chroot': $!";

for $svc (@ARGV) {
	push(@glob, glob($chroot . "/etc/rc[0-6S].d/[KS][0-9][0-9]$svc"));
}

@glob = glob($chroot . "/etc/rc[0-6S].d/[KS]*") unless @ARGV;

for (@glob) {
	next unless -L;
	next unless ($rlev, $sk, $pri, $svc) = m|/rc(.)\.d/([SK])([0-9]{2})(.+)$|;
	push(@{ $info{$svc}{$sk}{$pri} }, $rlev);
}

for $svc (sort keys %info) {

	# Prevent filling up variables with data from previous iterations
	# by starting from undefined state
	@par = ();
	$prm = undef;

	$frc and push(@par, "-f");

	next if not -x $chroot . "/etc/init.d/" . $svc;

	@s = keys %{ $info{$svc}{S} };
	@k = keys %{ $info{$svc}{K} };

	if ($rem) {
		push(@par, $svc, "remove");
	}
	elsif ( "@s" eq "20"
		and "@{$info{$svc}{S}{20}}" eq "2 3 4 5"
		and "@k"                    eq "20"
		and "@{$info{$svc}{K}{20}}" eq "0 1 6") {
		push(@par, $svc, "defaults");
	}
	else {
		$prm .= "start $_ @{$info{$svc}{S}{$_}} . " for (@s);
		$prm .= "stop $_ @{$info{$svc}{K}{$_}} . "  for (@k);
		push(@par, $svc, $prm) if $prm;
	}

	$found++;
	print "$urcd @par\n";
	system($urcd, @par) if $doit;
}

# If specific services were passed on the command line,
# test if as much services were found and reported as requested
@ARGV and $found == @ARGV or exit 1;
exit 0;
