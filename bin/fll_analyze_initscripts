#!/usr/bin/perl

# Warnings is much too loud, and i'm not the only one to
# complain about that, seen tutorials online that advise
# to only enable it when needed, for debugging. I agree.
#use warnings;
use strict;

#use Data::Dumper;
use Getopt::Long qw(:config bundling no_auto_abbrev);

# bundling is combining multiple short options together,
# no_auto_abbrev makes sure the error messages never
# abbreviate the parameter that was unknown.

# Declare all variables used in main here for oversight,
# except loop variables, because they don't persist.
# Variables start with undefined values, which evaluates
# to "" in scalar context.
my (%init, @glob);
my ($blist, $wlist);
my ($chroot, $found, $frc, $keep, $rem);
my $urcd = "update-rc.d";

GetOptions(
	"b|blacklist=s" => \$blist,
	"c|chroot=s"    => \$chroot,
	"f|force"       => \$frc,
	"k|keep"        => \$keep,
	"r|remove"      => \$rem,
	"w|whitelist=s" => \$wlist,
);

-d $chroot . "/etc/rcS.d/" or die "invalid chroot '$chroot': $!";

for my $svc (@ARGV) {
	push(@glob, glob($chroot . "/etc/rc[0-6S].d/[KS][0-9][0-9]$svc"));
}

@glob = glob($chroot . "/etc/rc[0-6S].d/[KS]*") unless @ARGV;

for (@glob) {
	next unless -L;
	next unless my ($rlev, $sk, $pri, $svc) = m|/rc(.)\.d/([SK])([0-9]{2})(.+)$|;
	push(@{ $init{$svc}{$sk}{$pri} }, $rlev);
}

#print Dumper \%init;

sub bnwlist {
	my ($b, $w) = (shift, shift);

	-s $b or die "Cannot read $b: $!\n";
	-s $w or die "Cannot read $w: $!\n";

	my (%binit, %winit);

	open(my $fh, '<', $b) or die "Cannot open $b: $!\n";
	while (<$fh>) {
		chomp;
		/^#/ and next;

		# script name
		if (m|^/etc/init.d/(.+)$|) {
			-x and $binit{$1}++;
			next;
		}

		# package name
		open(my $dq, '-|', "dpkg-query -L $_ 2>/dev/null")
			or die "Cannot execute dpkg-query: $!\n";
		while (<$dq>) {
			chomp;
			if (-x and m|^/etc/init.d/(.+)$|) {
				$binit{$1}++;
			}
		}
		close($dq);
	}
	close($fh);

	#print Dumper \%binit;

	open(my $fh, '<', $w) or die "Cannot open $w: $!\n";
	while (<$fh>) {
		chomp;
		/^#/ and next;

		# script name
		if (m|^/etc/init.d/(.+)$|) {
			-x and $binit{$1}++;
			next;
		}

		# package name
		open(my $dq, '-|', "dpkg-query -L $_ 2>/dev/null")
			or die "Cannot execute dpkg-query: $!\n";
		while (<$dq>) {
			chomp;
			if (-x and m|^/etc/init.d/(.+)$|) {

				# check for blacklisting
				$binit{$1} or $winit{$1}++;
			}
		}
		close($dq);
	}
	close($fh);

	#print Dumper \%winit;

	for my $svc (sort keys %init) {
		my $out;

		if ($keep) {
			$winit{$svc} and $out = $svc;
		}
		elsif ($rem) {
			$winit{$svc} or $out = $svc;
		}
		else {
			$out = $winit{$svc} ? "W: $svc" : "B: $svc";
		}

		print "$out\n" if $out;
	}
}

sub analyze {
	for my $svc (sort keys %init) {
		my (@par, $prm);

		$frc and push(@par, "-f");

		next if not -x $chroot . "/etc/init.d/" . $svc;

		my @s = keys %{ $init{$svc}{S} };
		my @k = keys %{ $init{$svc}{K} };

		if ($rem) {
			push(@par, $svc, "remove");
		}
		elsif ( "@s" eq "20" and "@k" eq "20"
			and "@{ $init{$svc}{S}{20} }" eq "2 3 4 5"
			and "@{ $init{$svc}{K}{20} }" eq "0 1 6") {
			push(@par, $svc, "defaults");
		}
		else {
			$prm .= "start $_ @{ $init{$svc}{S}{$_} } . " for (@s);
			$prm .= "stop $_ @{ $init{$svc}{K}{$_} } . "  for (@k);
			push(@par, $svc, $prm) if $prm;
		}

		$found++;
		print "$urcd @par\n";
	}

	my $eval = (@_ and $found != @_) ? 1 : 0;
	exit($eval);
}

if ($blist and $wlist) {
	bnwlist($blist, $wlist);
}
else {
	analyze(@ARGV);
}
