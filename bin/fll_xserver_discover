#!/usr/bin/perl
#
# Copyright (C) 2007 Kel Modderman <kel@otaku42.de>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this package; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
# MA 02110-1301, USA.
#
# On Debian GNU/Linux systems, the text of the GPL license can be
# found in /usr/share/common-licenses/GPL.
#
# Based on:
#   hwsetup-xserver-discover, a Perl script that returns the driver and 
#   description for the videocard detected in the machine it runs on, 
#   plus fallback methods.
#   Copyright (C) 2006  M.L. de Boer a.k.a locsmif <locsmif@kanotix.com>
#   (Sorry, the script is much bigger ang uglier now!)

use warnings;
use strict;
use File::Slurp qw(slurp read_dir);
use Getopt::Long;

use constant {
	VGA => '0300',
	PCILST => '/lib/discover/pci.lst',
	PCIIDS => '/usr/share/xserver-xorg/pci/',
};

my ($debug, $discover);

GetOptions(
        'verbose' => \$debug,
        'discover' => \$discover,
);

if ($debug) {
	require Data::Dumper;
	import Data::Dumper;
	print "Debugging...\n";
}

sub dbg {
	return unless $debug;
	
	for my $data (@_) {
		next unless $data;

		if (ref $data) {
			print STDERR "DBG: " . Dumper($data);
		}
		else {
			print STDERR "DBG: $data\n";
		}
	}
}

sub process {
	my $syspci = shift;
	return unless -d $syspci;

	my ($busid, $boardname, $device, $module, $vendor, $vendorname);

	# Get vendor and device
	$vendor = substr(slurp("$syspci/vendor"),2,4);
	$device = substr(slurp("$syspci/device"),2,4);
	chomp($vendor, $device);
	dbg "\$vendor: $vendor \$device: $device";

	# strip leading pathname
	$syspci =~ s|.*/([^/]+)$|$1|;
	dbg "\$syspci: $syspci";

	# Get BusID, ref: xserver-xorg.postinst
	if ($syspci =~  m/^(\w+):(\w+):(\w+)\.(\w+)$/) { 
		$busid = join(':', 'PCI', hex("0x$2"),  hex("0x$3"), hex("0x$4"));
		dbg "\$busid: $busid";
	}

	if ($discover and -T PCILST) {
		dbg "Opening libdiscover1 pci.lst...";
		# Open PCILST for reading
		open(F, '<', PCILST) or die("Failed to open pci.lst: $!\n");
		while (<F>) {
			chomp;
			# Inside vendor block and new vendor block found? Then exit loop.
			$vendorname and last if /^\w/;
			# Inside vendor?
			if ($vendorname) {
				# Match vendor and device of GFX card found or match fallback driver(ffffffff)?
				if (/^\t(?:${vendor}${device}|ffffffff)\t(\S+)\t(\S+\((\S+)\))\t(.+)$/) {
					# Get strings captured from backreferences above.
					($module, $boardname) = ($3, "$vendorname $4");
					dbg "\$module: $module \$boardname: $boardname";
					# Break loop
					last;
				}
			}
			# Found target vendor block? Set $vendorname with the vendor name captured from backref.
			/^$vendor\s+(.*)$/ and $vendorname = $1;
		}
		close(F);
	}
	else {
		# Discussion about source and creation of pci-id lists
		# http://lists.freedesktop.org/archives/xorg/2007-August/027567.html
		dbg "Looking for ${vendor}${device} in Xorg xserver pci.ids lists...";
		IDS: for my $ids (read_dir(PCIIDS)) {
			dbg "open(" . PCIIDS . "${ids})";
			open(my $fh, '<', PCIIDS . $ids)
				or die "Unable to read " . PCIIDS . $ids . ": $!\n";
			while(<$fh>) {
				chomp;
				dbg $_;
				if (/^${vendor}${device}$/i) {
					($module = $ids) =~ s/\.ids$//;
					dbg "\$module: $module";
					last IDS;
				}
			}
			close($fh);
		}

		dbg "Invoking lspci to lookup \$boardname...";
		# lspci lookup by $vendor:$device pair or by pci domain
		if ($syspci) {
			dbg "lspci -s $syspci";
			$boardname = `LC_ALL=C lspci -s $syspci 2>/dev/null`;
		}
		else {
			dbg "lspci -d ${vendor}:${device}";
			$boardname = `LC_ALL=C lspci -d ${vendor}:${device} 2>/dev/null`;
		}
		
		if ($boardname) {
			# trim the string
			chomp($boardname);
			$boardname =~ s/^.*:\s+//;
			$boardname =~ s/\s+\(rev\s+\d+\)$//;
			dbg "\$boardname: $boardname";
		}
	}

	# fallbacks
	$module ||= 'vesa';
	$boardname ||= "Unknown VGA Controller ${vendor}:${device}";

	# Output stuff that can be sourced by shellscripts.
	print "XMODULE=\"$module\"\n";
	print "XBOARDNAME=\"$boardname\"\n";
	print "XBUSID=\"$busid\"\n" if $busid;
}

# Glob /sys/devices/pci*/*/class and /sys/device/pci*/*/*/class
dbg "Globbing /sys/devices/pci*/*/class and /sys/device/pci*/*/*/class";
for (</sys/devices/pci*/*{,/*}/class>) {
	dbg $_;
	# Check for type VGA (see use constant at the top)
	if (substr(slurp($_),2,4) eq VGA) {
		# Strip '/class' from the end of the path
		s|/class$||;
		process($_);
		last;
	}
}
