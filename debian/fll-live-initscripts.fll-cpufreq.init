#!/bin/dash

### BEGIN INIT INFO
# Provides:          fll-cpufreq
# Required-Start:    
# Required-Stop:     
# Default-Start:     S
# Default-Stop:      
# Short-Description: load cpufreq support for cpu's that support it
# Description:       The purpose of fll-cpufreq is to detect and load cpu
#                    frequency management support for cpu's that support that
#                    in order to save power.
### END INIT INFO

###
# F.U.L.L.S.T.O.R.Y init script
#
# Copyright: (C) 2007 F.U.L.L.S.T.O.R.Y Project
# License:   GPLv2
#
# F.U.L.L.S.T.O.R.Y Project Homepage:
# http://developer.berlios.de/projects/fullstory
###

PATH=/sbin:/usr/sbin:/bin:/usr/bin
NAME="fll-cpufreq"

###
# source distro-defaults, no-op unless in live mode
###
FLL_DISTRO_MODE="installed"

if [ -s /etc/default/distro ]; then
	. /etc/default/distro
fi

if [ "${FLL_DISTRO_MODE}" != "live" ]; then
	exit 0
fi

###
# VERBOSE setting and other rcS variables
###
#. /lib/init/vars.sh

###
# source lsb functions
###
. /lib/lsb/init-functions

###
# ANSI escape sequences (N, R, G, Y, B, M, C, W)
###
. /lib/fll/fll-init-cols

###
# cheatcode handling
###
if [ -f /proc/cmdline ]; then
	for param in $(cat /proc/cmdline); do
		case "${param}" in
			flldebug=*)
				[ "${param#flldebug=}" = "${NAME#fll-}" ] && set -x
				;;
			nocpufreq|cpufreq=no)
				update-rc.d -f powersaved remove >/dev/null 2>&1
				update-rc.d -f powernowd remove >/dev/null 2>&1
				exit 0
				;;
		esac
	done
fi

do_start() {
	#if /usr/sbin/laptop-detect; then LAPTOP=1; fi
	CPUINFO=/proc/cpuinfo
	IOPORTS=/proc/ioports

	[ -f ${CPUINFO} ] || exit 0

	MODEL_NAME=$(grep '^model name' "${CPUINFO}" | head -1 | sed -e 's/^.*: //;')
	CPU=$(grep -E '^cpud[^:]+:' "$CPUINFO" | head -1 | sed -e 's/^.*: //;')
	VENDOR_ID=$(grep -E '^vendor_id[^:]+:' "${CPUINFO}" | head -1 | sed -e 's/^.*: //;')
	CPU_FAMILY=$(sed -e '/^cpu family/ {s/.*: //;p;Q};d' ${CPUINFO})

	CPUFREQ=

	# Two modules for PIII-M depending the chipset.
	if [ -f ${IOPORTS} ] && grep -q 'Intel .*ICH' ${IOPORTS} ; then
		PIII_CPUFREQ=speedstep-ich
	else
		PIII_CPUFREQ=speedstep-smi
	fi

	case "${VENDOR_ID}" in
		GenuineIntel*)
			# If the CPU has the est flag, it supports enhanced speedstep and should
			# use the acpi-cpufreq driver (speedstep-centrino is deprecated)
			if grep -q est ${CPUINFO}; then
				CPUFREQ=acpi-cpufreq;
			elif [ $CPU_FAMILY = 15 ]; then
				# Right. Check if it's a P4 without est.
				# Could be speedstep-ich.
				CPUFREQ=speedstep-ich;
			else
				# So it doesn't have Enhanced Speedstep, and it's not a P4. It could be 
				# a Speedstep PIII, or it may be unsupported. There's no terribly good
				# programmatic way of telling.
				case "${MODEL_NAME}" in
					Intel\(R\)\ Pentium\(R\)\ III\ Mobile\ CPU*)
						CPUFREQ=${PIII_CPUFREQ}
						;;
					# JD: says this works with   cpufreq_userspace
					Mobile\ Intel\(R\)\ Pentium\(R\)\ III\ CPU\ -\ M*)
						CPUFREQ=${PIII_CPUFREQ}
						;;
					# https://bugzilla.ubuntu.com/show_bug.cgi?id=4262
					# UNCONFIRMED
					Pentium\ III\ \(Coppermine\)*)
						CPUFREQ=${PIII_CPUFREQ}
						;;
				esac
			fi
			;;
		AuthenticAMD*)
			# Hurrah. This is nice and easy.
			case ${CPU_FAMILY} in
				5)
					# K6
					CPUFREQ=powernow-k6
					;;
				6)
					# K7
					CPUFREQ=powernow-k7
					;;
				15)
					# K8
					CPUFREQ=powernow-k8
					;;
			esac
			;;
		CentaurHauls*)
			# VIA
			if [ "${CPU_FAMILY}" = 6 ]; then
				CPUFREQ=longhaul;
			fi
			;;
		GenuineTMx86*)
			# Transmeta
			if grep -q longrun ${CPUINFO}; then
				CPUFREQ=longrun
			fi
			;;
	esac

	if [ "${CPUFREQ}" ]; then
		if modprobe "${CPUFREQ}" 2>/dev/null; then
			# start cpufreq power services
			:
		else
			unset CPUFREQ
		fi
	fi
		
	# always try acpi-cpufreq as fallback when acpi support is present
	if [ -z "${CPUFREQ}" ] && [ -d /proc/acpi ]; then
		if modprobe acpi-cpufreq 2>/dev/null; then
			CPUFREQ=acpi-cpufreq
		fi
	fi

	if [ "${CPUFREQ}" ]; then
		log_daemon_msg "${B}${NAME}${N}" "${G}detected '${Y}${CPUFREQ}${G}' cpufreq support${N}"
		###
		# load all cpufreq related policy and support modules
		###
		CPUFREQ_MODDIR="/lib/modules/$(uname -r)/kernel/drivers/cpufreq"
		if [ -d "${CPUFREQ_MODDIR}" ]; then
			CPUFREQ_MODULES=$(find ${CPUFREQ_MODDIR} \
				-type f -name "*.ko" -printf "basename %f .ko\n" | /bin/sh)
			if [ "${CPUFREQ_MODULES}" ]; then
				for kmod in ${CPUFREQ_MODULES}; do
					grep -q -w ${kmod} /proc/modules || modprobe ${kmod} 2>/dev/null
				done
			fi
		fi
		log_end_msg 0
	else
		###
		# purge these services from latter runlevels, no cpufreq support
		###
		update-rc.d -f powersaved remove >/dev/null 2>&1
		update-rc.d -f powernowd remove >/dev/null 2>&1
	fi

	# manage /etc/modules, in a persistent setup we may have written a different module
	# to /etc/modules
	CPUFREQ_MODDIR=$(find /lib/modules/$(uname -r)/kernel/arch/ -path '*/cpufreq')
	CPUFREQ_MODULES=$(find ${CPUFREQ_MODDIR} \
		-type f -name "*.ko" -printf "basename %f .ko\n" 2>/dev/null | /bin/sh)
	if [ "${CPUFREQ_MODULES}" ]; then
		CPUFREQ_REGEXP=$(echo ${CPUFREQ_MODULES} | sed -e 's/[[:space:]]/|/g' -e 's/[-_]/\[-_\]/g')
		CPUFREQ_MATCH=$(grep -s -E "^(${CPUFREQ_REGEXP})" /etc/modules)
		if [ "${CPUFREQ}" ] && [ "${CPUFREQ_MATCH}" ]; then
			# replace
			sed -i "s/${CPUFREQ_MATCH}/${CPUFREQ}/" /etc/modules
		elif [ -z "${CPUFREQ}" ] && [ "${CPUFREQ_MATCH}" ]; then
			# remove
			sed -i "/${CPUFREQ_MATCH}/d" /etc/modules
		elif [ "${CPUFREQ}" ]; then
			# add
			echo "${CPUFREQ}" >> /etc/modules
		fi
	fi
}

case "${1}" in
	start)
		do_start
		;;
	stop)
		;;
	restart|force-reload)
		echo "Error: argument '${1}' not supported" >&2
		exit 3
		;;
	*)
		echo "Usage: ${NAME} {start|stop|restart|force-reload}" >&2
		exit 3
		;;
esac

:
