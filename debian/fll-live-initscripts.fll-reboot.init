#!/bin/sh

### BEGIN INIT INFO
# Provides:          halt reboot
# Required-Start:
# Required-Stop:
# Default-Start:
# Default-Stop:      0 6
# Short-Description: shutdown and eject live media
# Description:       This script provides the equivalent of umountfs,
#                    umountroot, reboot and halt on a standard debian system.
#                    It umounts live mounts and ejects the live media at
#                    shutdown/reboot.
### END INIT INFO

###
# F.U.L.L.S.T.O.R.Y init script
#
# Copyright: (C) 2007 - 2008 Kel Modderman <kel@otaku42.de>
# License:   GPLv2
#
# F.U.L.L.S.T.O.R.Y Project Homepage:
# http://developer.berlios.de/projects/fullstory
###

PATH=/sbin:/usr/sbin:/bin:/usr/bin
NAME="fll-reboot"

###
# source distro-defaults, no-op unless in live mode
###
FLL_DISTRO_MODE="installed"

if [ -s /etc/default/distro ]; then
	. /etc/default/distro
fi

if [ "${FLL_DISTRO_MODE}" != "live" ]; then
	exit 0
fi

###
# VERBOSE setting and other rcS variables
###
. /lib/init/vars.sh

###
# source lsb functions
###
. /lib/lsb/init-functions

###
# source fll functions
###
. /lib/init/fll

###
# define this for copy_exec
###
DESTDIR="/live-hack"

if [ -f /proc/cmdline ]; then
	for param in $(cat /proc/cmdline); do
		case "${param}" in
			flldebug=*)
				[ "${param#flldebug=}" = "${NAME#fll-}" ] && set -x
				;;
			noeject|toram)
				NOEJECT="1"
				;;
			noprompt)
				NOPROMPT="1"
				;;
		esac
	done
fi

###############################################################################
# Adapted from initscripts: /etc/init.d/umountfs (2.86.ds1-38)
###############################################################################
# Print in order of decreasing length
#
# Algorithm: Find and print longest argument, then call self
# to print remaining arguments in order of decreasing length
#
# This function runs at one tenth the speed of the sort program
# but we use the function because we don't want to rely on any
# programs in /usr/.
#
# N.B.: Arguments must not be null and must not contain whitespace
#
pioodl() {
	[ "$1" ] || return 0
	
	ARGNUM=1
	ARGNUM_LONGEST=0
	ARGLENGTH_LONGEST=0
	for ARG in "$@"
	do
		ARGLENGTH="${#ARG}"
		if [ "$ARGLENGTH" -gt "$ARGLENGTH_LONGEST" ]
		then
			ARGLENGTH_LONGEST="$ARGLENGTH"
			ARGNUM_LONGEST="$ARGNUM"
		fi
		ARGNUM=$(($ARGNUM + 1))
	done
	
	# The method of passing prevargs assumes that args can be
	# delimited with spaces
	ARGNUM=1
	PREVARGS=""
	while [ "$ARGNUM" -lt "$ARGNUM_LONGEST" ]
	do
		PREVARGS="$PREVARGS $1"
		shift
		ARGNUM=$(($ARGNUM + 1))
	done
	echo "$1"
	shift
	
	pioodl $PREVARGS "$@"
}

do_umount() {
	exec 9<&0 < /proc/mounts

	REG_MTPTS=""
	TMPFS_MTPTS=""
	while read DEV MTPT FSTYPE OPTS REST
	do
		case "$MTPT" in
			#
			# live hack
			#
			/fll/*)
				case "$FSTYPE" in
					iso9660)
						[ "$MTPT" = /fll/fromiso ] && LIVE_MTPTS="$LIVE_MTPTS $MTPT"
						;;
					*)
						LIVE_MTPTS="$LIVE_MTPTS $MTPT"
						;;
				esac
				continue
				;;
			#
			# live hack
			#
			/|/proc|/dev|/.dev|/dev/pts|/dev/shm|/dev/.static/dev|/proc/*|/sys|/lib/init/rw)
				continue
				;;
			/var/run)
				if [ yes = "$RAMRUN" ] ; then
					continue
				fi
				;;
			/var/lock)
				if [ yes = "$RAMLOCK" ] ; then
					continue
				fi
				;;
		esac
		case "$FSTYPE" in 
			proc|procfs|linprocfs|devfs|sysfs|usbfs|usbdevfs|devpts)
				continue
				;;
			#
			# live hack
			#
			aufs|unionfs)
				UNION_MTPTS="$UNION_MTPTS $MTPT"
				;;
			squashfs)
				SQUSH_MTPTS="$SQUSH_MTPTS $MTPT"
				;;
			#
			# live hack
			#
			tmpfs)
				TMPFS_MTPTS="$TMPFS_MTPTS $MTPT"
				;;
			*)
				REG_MTPTS="$REG_MTPTS $MTPT"
				;;
		esac
	done

	exec 0<&9 9<&-
	
	#
	# Make sure tmpfs file systems are umounted before turning off
	# swap, to avoid running out of memory if the tmpfs filesystems
	# use a lot of space.
	#
	if [ "$TMPFS_MTPTS" ]
	then
		TMPFS_MTPTS="$(pioodl $TMPFS_MTPTS)"
		if [ "$VERBOSE" = no ]
		then
			log_action_begin_msg "Unmounting temporary filesystems"
			umount $TMPFS_MTPTS
			log_action_end_msg $?
		else
			log_daemon_msg "Will now unmount temporary filesystems"
			umount -v $TMPFS_MTPTS
			log_end_msg $?
		fi
	fi

	#
	# Deactivate swap
	#
	if [ "$VERBOSE" = no ]
	then
		log_action_begin_msg "Deactivating swap"
		swapoff -a >/dev/null
		log_action_end_msg $?
	else
		log_daemon_msg "Will now deactivate swap"
		swapoff -a -v
		log_end_msg $?
	fi

	#
	# Unmount local filesystems
	#
	if [ "$REG_MTPTS" ]
	then
		REG_MTPTS="$(pioodl $REG_MTPTS)"
		if [ "$VERBOSE" = no ]
		then
			log_action_begin_msg "Unmounting local filesystems"
			umount -n -f -r -d $REG_MTPTS
			log_action_end_msg $?
		else
			log_daemon_msg "Will now unmount local filesystems"
			umount -n -f -v -r -d $REG_MTPTS
			log_end_msg $?
		fi
	fi

	#
	# live hack: any command after this point must be prefixed with ${BINDIR}
	#
	if [ "$UNION_MTPTS" ]
	then
		UNION_MTPTS="$(pioodl $UNION_MTPTS)"
		if [ "$VERBOSE" = no ]
		then
			log_action_begin_msg "Unmounting union filesystems"
			${BINDIR}umount -l -n -f -d $UNION_MTPTS
			log_action_end_msg $?
		else
			log_daemon_msg "Will now unmount union filesystems"
			${BINDIR}umount -l -n -f -v -d $UNION_MTPTS
			log_end_msg $?
		fi
	fi

	if [ "$SQSH_MTPTS" ]
	then
		SQSH_MTPTS="$(pioodl $SQSH_MTPTS)"
		if [ "$VERBOSE" = no ]
		then
			log_action_begin_msg "Unmounting squashfs filesystems"
			${BINDIR}umount -l -n -f -d $SQSH_MTPTS
			log_action_end_msg $?
		else
			log_daemon_msg "Will now unmount squashfs filesystems"
			${BINDIR}umount -l -n -f -v -d $SQSH_MTPTS
			log_end_msg $?
		fi
	fi

	if [ "$LIVE_MTPTS" ]
	then
		LIVE_MTPTS="$(pioodl $LIVE_MTPTS)"
		if [ "$VERBOSE" = no ]
		then
			log_action_begin_msg "Unmounting live filesystems"
			${BINDIR}umount -l -n -f -d $LIVE_MTPTS
			log_action_end_msg $?
		else
			log_daemon_msg "Will now unmount live filesystems"
			${BINDIR}umount -l -n -f -v -d $LIVE_MTPTS
			log_end_msg $?
		fi
	fi
}
###############################################################################
# Adapted from initramfs-tools hook-functions (0.87b)
###############################################################################
# $1 is source
# $2 is relative destination
copy_exec() {
	verbose="${VERBOSE}"
	final_destination=${DESTDIR}/${2}/$(basename ${1})
	
	if [ -L "$final_destination" ]; then
		if ! [ `readlink ${final_destination}` = "${1}" ]; then
			return
		fi
	else
		cp ${1} ${DESTDIR}/${2}
		if [ -n "${verbose}" ] && [ "${verbose}" = "y" ]; then
			echo "Adding binary ${1}"
		fi
	fi

	# Copy the dependant libraries
	for x in $(ldd ${1} 2>/dev/null | sed -e '
	    /\//!d;
	    /linux-gate/d;
	    /=>/ {s/.*=>[[:blank:]]*\([^[:blank:]]*\).*/\1/};
	    s/[[:blank:]]*\([^[:blank:]]*\) (.*)/\1/' 2>/dev/null); do

		# Try to use non-optimised libraries where possible.
		# We assume that all HWCAP libraries will be in tls.
		nonoptlib=$(echo ${x} | sed -e 's#/lib/tls.*/\(lib.*\)#/lib/\1#')

		if [ -e ${nonoptlib} ]; then
			x=${nonoptlib}
		fi

		libname=$(basename ${x})
		dirname=$(dirname ${x})

		mkdir -p ${DESTDIR}/${dirname}
		if [ ! -e ${DESTDIR}/${dirname}/${libname} ]; then
			cp ${x} ${DESTDIR}/${dirname}
			if [ -n "${verbose}" ] && [ "${verbose}" = "y" ]; then
				echo "Adding library ${x}"
			fi
		fi
	done
}
###############################################################################
# End adapted functions
###############################################################################

live_hack() {
	mkdir -p ${DESTDIR}/bin
	
	# cache utilities required for the final stages of shutdown
	for path in $(which umount) $(which halt) $(which reboot) $(which eject); do
		copy_exec "${path}" /bin
	done
	
	LD_LIBRARY_PATH="${DESTDIR}/lib"
	if [ -e "${DESTDIR}/lib64" ]; then
		LD_LIBRARY_PATH="${DESTDIR}/lib64:${LD_LIBRARY_PATH}"
	fi
	export LD_LIBRARY_PATH

	LD_LINUX="${DESTDIR}/lib/ld-linux.so.2"
	if [ -e "${DESTDIR}/lib64/ld-linux-x86-64.so.2" ]; then
		LD_LINUX="${DESTDIR}/lib64/ld-linux-x86-64.so.2"
	elif [ ! -e $LD_LINUX ]; then
		LD_LINUX="${DESTDIR}/lib/ld.so.1"
		if [ -e "${DESTDIR}/lib64/ld64.so.1" ]; then
			LD_LINUX="${DESTDIR}/lib64/ld64.so.1"
		fi
	fi
	export LD_LINUX

	PATH="${DESTDIR}/bin:${PATH}"
	export PATH

	BINDIR="${LD_LINUX} ${DESTDIR}/bin/"
	export BINDIR
}

do_stop() {
	# calculate runlevel
	runlevel="$(runlevel)"
	runlevel="${runlevel#* }"

	# set sane defaults for /dev/console
	stty sane < /dev/console

	# prepare binaries for post-umount of live media
	live_hack

	# umount the live media and other mount points
	do_umount

	case "${runlevel}" in
		0)
			echo "System halted." > /dev/console
			command="halt"
			options="-h -n -p -i -f"
			;;
		6)
			echo "Preparing for reboot..." > /dev/console
			command="reboot"
			options="-n -i -f"
			;;
		*)
			echo "${NAME}: attempted execution in invalid runlevel!"
			exit 1
			;;
	esac

	if [ -b /dev/fll-cdrom ] && [ -z "${NOEJECT}" ]; then
		# disable kernel messages while ejecting cdrom (libata noise)
		echo "0" > /proc/sys/kernel/printk

		${BINDIR}eject -m -p /dev/fll-cdrom

		if [ -z "${NOPROMPT}" ]; then
			echo ""
			echo "Please remove CD, close cdrom drive then press enter." > /dev/console
			echo ""
			read x < /dev/console
		fi
	fi

	# shutdown/reboot	
	exec ${BINDIR}${command} ${options} > /dev/console 2>&1 < /dev/console
}

case "${1}" in
	start)
		# no-op
		;;
	restart|reload|force-reload)
		echo "Error: argument '${1}' not supported" >&2
		exit 3
		;;
	stop)
		# live-hack, umount and eject
		do_stop
		;;
	*)
		echo "Usage: ${NAME} {start|stop}" >&2
		exit 3
		;;
esac
