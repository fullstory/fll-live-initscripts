#!/bin/dash

### BEGIN INIT INFO
# Provides:          fll-xorgconfig
# Required-Start:    
# Required-Stop:     
# Default-Start:     S
# Default-Stop:      0 1 6
# Short-Description: configure Xorg xserver
# Description:       The script is intended to configure the
#                    Xorg xserver for use.
### END INIT INFO

###
# F.U.L.L.S.T.O.R.Y init script
#
# Copyright: (C) 2007 F.U.L.L.S.T.O.R.Y Project
# License:   GPLv2
#
# F.U.L.L.S.T.O.R.Y Project Homepage:
# http://developer.berlios.de/projects/fullstory
###

PATH=/sbin:/usr/sbin:/bin:/usr/bin
NAME="fll-xorgconfig"

###
# source distro-defaults, no-op unless in live mode
###
FLL_DISTRO_MODE="installed"

if [ -s /etc/default/distro ]; then
	. /etc/default/distro
fi

if [ "${FLL_DISTRO_MODE}" != "live" ]; then
	exit 0
fi

if [ ! -x /usr/sbin/fll_xorgconfig ] || [ ! -x /usr/sbin/fll_xserver_discover ]; then
	exit 0
fi

# XKBLAYOUT is stored here by /etc/init.d/fll-locales
if [ -s /etc/default/fll-locales ]; then
	. /etc/default/fll-locales
fi

###
# source lsb functions
###
. /lib/lsb/init-functions

###
# ANSI escape sequences (N, R, G, Y, B, M, C, W)
###
. /lib/fll/fll-init-cols

###
# cheatcode handling
###
if [ -f /proc/cmdline ]; then
	for param in $(cat /proc/cmdline); do
		case "${param}" in
			flldebug=*)
				[ "${param#flldebug=}" = "${NAME#fll-}" ] && set -x
				;;
			noxorgconfig|xorgconfig=no)
				exit 0
				;;
			noxrandr)
				XNOXRANDR="1"
				;;
			nomodelines|noml)
				XNOMODELINES="1"
				;;
			smouse)
				XPROBE_SERIAL_MOUSE="1"
				;;
			xdepth=*|depth=*)
				XDEPTH="${param#*depth=}"
				;;
			xhrefresh=*|hsync=*)
				XHORIZSYNC="${param#*=}"
				;;
			xkblayout=*)
				XKBLAYOUT="${param#xkblayout=}"
				;;
			xkbmodel=*)
				XKBMODEL="${param#xkbmodel=}"
				;;
			xkboptions=*)
				XKBOPTIONS="${param#xkboptions=}"
				;;
			xkbvariant=*)
				XKBVARIANT="${param#xkbvariant=}"
				;;
			xmodule=*)
				XNEWMODULE="${param#xmodule=}"
				;;
			xrate=*|rate=*)
				XRATE="${param#*rate=}"
				;;
			xrandr)
				XFORCERANDR="1"
				;;
			xscreen=*|screen=*|xmode=*|mode=*)
				XMODES="${param#*=}"
				;;
			xvrefresh=*|vsync=*)
				XVERTREFRESH="${param#*=}"
				;;
		esac
	done
fi

###
# functions...
###
xserver_has_xrandr() {
	[ "${1}" ] && [ -z "${XNOXRANDR}" ] || return 1
	
	if [ "${XFORCERANDR}" ]; then
		# force xrandr style configuration
		return 0
	fi

	# http://wiki.debian.org/XStrikeForce/HowToRandR12
	# As of today (20071015), the following drivers/boards support RandR 1.2:
	#  * the Intel driver on all boards (since 1.9.91)
	#  * the NV driver on G80 boards (since 2.0.95)
	#  * the ATI driver on r200/r300/r400 boards (since 6.7.191)
	#  * the MGA driver on all boards (since 1.9.99)

	# xserver driver
	local DRIVER="${1}"
	# device id of VGA hardware (lower case)
	local DEVICE="${2}"
	
	# package version with randr1.2 support
	local VERSION_HAS_RANDR

	case "${DRIVER}" in
		ati)
			VERSION_HAS_RANDR="1:6.7.191-1"
			# find ${DEVICE} in a list of r200/r300/r400 device ids
			if [ -z "${DEVICE}" ] || ! grep -s -q "^${DEVICE}" \
				"/usr/share/fll-live-xorgconfig/xrandr/${DRIVER}"; then
				return 1
			fi
			;;
		intel)
			VERSION_HAS_RANDR="2:2.1.0-1"
			;;
		mga)
			VERSION_HAS_RANDR="1:1.9.99.dfsg.1-1"
			;;
		nv)
			VERSION_HAS_RANDR="1:2.0.96-1"
			# find ${DEVICE} in a list of G8x device ids
			if [ -z "${DEVICE}" ] || ! grep -s -q "^${DEVICE}" \
				"/usr/share/fll-live-xorgconfig/xrandr/${DRIVER}"; then
				return 1
			fi
			;;
		*)
			return 1
			;;
	esac

	# get xserver-xorg-video-$driver package version
	local VERSION=$(dpkg -l "xserver-xorg-video-${DRIVER}" | awk '/^ii/{ print $3 }')

	# compare versions, return status
	if [ "${VERSION}" ]; then
		dpkg --compare-versions "${VERSION}" ge "${VERSION_HAS_RANDR}"
		return "${?}"
	fi
	
	return 1
}

x_res_probe() {
	awk -F: -v driver="${1}" '
		BEGIN {
			cmd = "xresprobe " driver
			while ((cmd | getline) > 0) {
				sub(/^[ \t]+/,"",$2)
				if ($1 == "freq") {
					split($2,f," ")
					print "XHFREQ" "=\"" f[1] "\""
					print "XVFREQ" "=\"" f[2] "\""
					delete f
				}
				else 
					print "X" toupper($1) "=\"" $2 "\""
			}
		}'
}

do_start() {
	log_daemon_msg "${B}${NAME}${N}"
	log_action_begin_msg " ${G}detecting ${Y}video${G} hardware${N}"
	
	# fll_xorgconfig option array
	local XCFG_OPTS

	if [ "${VERBOSE}" = "yes" ]; then
		XCFG_OPTS="${XCFG_OPTS} --verbose"
	fi

	# sourced earlier from /etc/default/fll-locales
	if [ "${XKBLAYOUT}" ]; then
		XCFG_OPTS="${XCFG_OPTS} --xkblayout '${XKBLAYOUT}'"
	fi

	if [ "${XKBMODEL}" ]; then
		XCFG_OPTS="${XCFG_OPTS} --xkbmodel '${XKBMODEL}'"
	fi

	if [ "${XKBVARIANT}" ]; then
		XCFG_OPTS="${XCFG_OPTS} --xkbvariant '${XKBVARIANT}'"
	fi

	if [ "${XKBOPTIONS}" ]; then
		XCFG_OPTS="${XCFG_OPTS} --xkboptions '${XKBOPTIONS}'"
	fi

	# detect video hardware via fll_xserver_discover
	#     XMODULE XBOARDNAME XBUSID XVENDOR XDEVICE
	eval $(/usr/sbin/fll_xserver_discover 2>/dev/null)

	log_end_msg 0
	
	log_daemon_msg "${B}${NAME}${N}"

	if [ "${XNEWMODULE}" ]; then
		# user override
		log_progress_msg "${G}driver(*): ${Y}${XNEWMODULE}${N}"
		XCFG_OPTS="${XCFG_OPTS} --driver '${XNEWMODULE}'"
		XMODULE="${XNEWMODULE}"
	elif [ "${XMODULE}" ]; then
		log_progress_msg "${G}driver: ${Y}${XMODULE}${N}"
		XCFG_OPTS="${XCFG_OPTS} --driver '${XMODULE}'"

		# turn composite on for modules that support it well
		case "${XMODULE}" in
			intel)
				XCFG_OPTS="${XCFG_OPTS} --composite"
				;;
		esac
	fi

	if [ "${XVENDOR}" ] && [ "${XDEVICE}" ]; then
		log_progress_msg "${G}pciid: ${Y}${XVENDOR}:${XDEVICE}${N}"
	fi

	if [ "${XBUSID}" ]; then
		log_progress_msg "${G}busid: ${Y}${XBUSID}${N}"
		XCFG_OPTS="${XCFG_OPTS} --busid '${XBUSID}'"
	fi

	log_end_msg 0
	
	if [ "${XBOARDNAME}" ]; then
		log_daemon_msg "${B}${NAME}${N}"
		log_progress_msg "${G}device: ${Y}${XBOARDNAME}${N}"
		log_end_msg 0
		XCFG_OPTS="${XCFG_OPTS} --boardname '${XBOARDNAME}'"
	fi
	
	log_daemon_msg "${B}${NAME}${N}"
	log_action_begin_msg " ${G}detecting ${Y}monitor${G} settings${N}"
	log_end_msg 0

	log_daemon_msg "${B}${NAME}${N}"

	if xserver_has_xrandr "${XMODULE}" "${XDEVICE}"; then
		log_progress_msg "${G}driver has ${Y}RandR 1.2${G} support${N}"
		# xrandr aware, we don't have to probe monitor settings :)
		XCFG_OPTS="${XCFG_OPTS} --xrandr"
		
		if [ "${XMODES}" ]; then
			log_progress_msg "${Y}${XMODES}${N}"
			XCFG_OPTS="${XCFG_OPTS} --mode '${XMODES}'"
		fi

		# warn about override semantic difference
		if [ "${XVERTREFRESH}" ] && [ -z "${XRATE}" ]; then
			log_warning_msg "ignoring vsync=${XVERTREFRESH}"
		fi

		if [ "${XRATE}" ]; then
			log_progress_msg "${G}@${Y}${XRATE} Hz${N}"
			XCFG_OPTS="${XCFG_OPTS} --rate '${XRATE}'"
		fi

		log_end_msg 0
	else
		log_progress_msg "${G}xresprobe ${Y}${XMODULE}${G}:${N}"
		# legacy style config, we need to probe for optimal X settings
		#     XID XRES XHFREQ XVFREQ XDISPTYPE
		eval $(x_res_probe ${XMODULE})

		# probed
		if [ "${XID}" ]; then
			# too long: log_progress_msg "${G}id: ${Y}${XID}${N}"
			XCFG_OPTS="${XCFG_OPTS} --modelname '${XID}'"
		fi
		
		if [ "${XMODES}" ]; then
			# cheatcode
			log_progress_msg "${G}res(*): ${Y}${XMODES}${N}"
			XCFG_OPTS="${XCFG_OPTS} --modes '${XMODES}'"
		elif [ "${XRES}" ]; then
			# just announce the highest res detected
			log_progress_msg "${G}res: ${Y}${XRES%%\ *}${N}"
			# probed
			XCFG_OPTS="${XCFG_OPTS} --modes '${XRES}'"
		fi
		
		if [ "${XHORIZSYNC}" ]; then
			# cheatcode
			XHORIZSYNC_MIN="${XHORIZSYNC%%-*}"
			XHORIZSYNC_MAX="${XHORIZSYNC##*-}"

			if [ "${XHORIZSYNC_MIN}" = "${XHORIZSYNC}" ]; then
				XHORIZSYNC_MIN="28"
			fi

			log_progress_msg "${G}hfreq(*): ${Y}${XHORIZSYNC_MIN}-${XHORIZSYNC_MAX} kHz${N}"
			XCFG_OPTS="${XCFG_OPTS} --horizsync '${XHORIZSYNC_MIN}-${XHORIZSYNC_MAX}'"
		elif [ "${XHFREQ}" ]; then
			log_progress_msg "${G}hfreq: ${Y}${XHFREQ} kHz${N}"
			# probed
			XCFG_OPTS="${XCFG_OPTS} --horizsync '${XHFREQ}'"
		fi

		# warn about override semantic difference
		if [ "${XRATE}" ] && [ -z "${XVERTREFRESH}" ]; then
			log_warning_msg "ignoring xrate=${XRATE}"
		fi			
		
		if [ "${XVERTREFRESH}" ]; then
			# cheatcode
			XVERTREFRESH_MIN="${XVERTREFRESH%%-*}"
			XVERTREFRESH_MAX="${XVERTREFRESH##*-}"

			if [ "${XVERTREFRESH_MIN}" = "${XVERTREFRESH}" ]; then
				XVERTREFRESH_MIN="50"
			fi

			log_progress_msg "${G}vfreq(*): ${Y}${XVERTREFRESH_MIN}-${XVERTREFRESH_MAX} Hz${N}"
			XCFG_OPTS="${XCFG_OPTS} --vertrefresh '${XVERTREFRESH_MIN}-${XVERTREFRESH_MAX}'"
		elif [ "${XVFREQ}" ]; then
			# probed
			XVERTREFRESH_MIN="${XVFREQ%%-*}"
			XVERTREFRESH_MAX="${XVFREQ##*-}"

			if [ "${XVERTREFRESH_MAX}" -ge "85" ]; then
				# raise minimum vertical refresh threshold
				XVERTREFRESH_MIN="73"
				log_progress_msg "${G}vfreq(+): ${Y}${XVERTREFRESH_MIN}-${XVERTREFRESH_MAX} Hz${N}"
			else
				log_progress_msg "${G}vfreq: ${Y}${XVERTREFRESH_MIN}-${XVERTREFRESH_MAX} Hz${N}"
			fi

			XCFG_OPTS="${XCFG_OPTS} --vertrefresh '${XVERTREFRESH_MIN}-${XVERTREFRESH_MAX}'"
		fi

		# cheatcode
		if [ "${XNOMODELINES}" ]; then
			XCFG_OPTS="${XCFG_OPTS} --no-modelines"
		fi

		log_end_msg 0
	fi

	# x_res_probe() may also export this variable
	if [ "${XDEPTH}" ]; then
		XCFG_OPTS="${XCFG_OPTS} --colordepth '${XDEPTH}'"
	fi

	if [ "${XPROBE_SERIAL_MOUSE}" ]; then
		XCFG_OPTS="${XCFG_OPTS} --serial-mouse"
	fi

	# write the configuration to file
	eval "/usr/sbin/fll_xorgconfig ${XCFG_OPTS}"
}

case "${1}" in
	start)
		do_start
		;;
	stop)
		;;
	restart|force-reload)
		echo "Error: argument '${1}' not supported" >&2
		exit 3
		;;
	*)
		echo "Usage: ${NAME} {start|stop}" >&2
		exit 3
		;;
esac

:
