#!/bin/sh

### BEGIN INIT INFO
# Provides:          fll-xorgconfig
# Required-Start:    $remote_fs
# Required-Stop:
# Should-Start:      fll-locales
# X-Start-Before:    x11-common
# Default-Start:     S
# Default-Stop:
# Short-Description: configure Xorg xserver
# Description:       The script is intended to configure the
#                    Xorg xserver for use.
### END INIT INFO

###
# F.U.L.L.S.T.O.R.Y init script
#
# Copyright: (C) 2007 - 2008 Kel Modderman <kel@otaku42.de>
# License:   GPLv2
#
# F.U.L.L.S.T.O.R.Y Project Homepage:
# http://developer.berlios.de/projects/fullstory
###

PATH=/sbin:/usr/sbin:/bin:/usr/bin
NAME="fll-xorgconfig"
DPKG_ARCH="$(dpkg --print-architecture)"

###
# source distro-defaults, no-op unless in live mode
###
FLL_DISTRO_MODE="installed"

if [ -s /etc/default/distro ]; then
	. /etc/default/distro
fi

if [ "${FLL_DISTRO_MODE}" != "live" ]; then
	exit 0
fi

if [ ! -x /usr/sbin/fll_xorgconfig ] || [ ! -x /usr/sbin/fll_xserver_discover ]; then
	exit 0
fi

###
# source lsb functions
###
. /lib/lsb/init-functions

###
# source fll functions
###
. /lib/init/fll

###
# cheatcode handling
###
if [ -f /proc/cmdline ]; then
	for param in $(cat /proc/cmdline); do
		case "${param}" in
			flldebug=*)
				if [ "${param#flldebug=}" = "${NAME#fll-}" ] || [ "${param#flldebug=}" = "all" ]; then
					fll_redirect
				fi
				;;
			noxorgconfig|xorgconfig=no)
				exit 0
				;;
			noxrandr)
				XNOXRANDR="1"
				XOVERRIDE="1"
				;;
			noxresprobe|noxprobe)
				XNOXRESPROBE="1"
				;;
			nomodelines|noml)
				XNOMODELINES="1"
				;;
			xdepth=*|depth=*)
				XDEPTH="${param#*depth=}"
				XOVERRIDE="1"
				;;
			xhrefresh=*|hsync=*)
				XHORIZSYNC="${param#*=}"
				XOVERRIDE="1"
				;;
			xdriver=*|xmodule=*)
				XNEWMODULE="${param#x*=}"
				;;
			xrate=*|rate=*)
				XRATE="${param#*rate=}"
				XOVERRIDE="1"
				;;
			xrandr)
				XFORCERANDR="1"
				;;
			xscreen=*|screen=*|xmode=*|mode=*)
				XMODES="${param#*=}"
				XOVERRIDE="1"
				;;
			xvrefresh=*|vsync=*)
				XVERTREFRESH="${param#*=}"
				XOVERRIDE="1"
				;;
			vesa)
				XNEWMODULE="vesa"
				;;
		esac
	done
fi

###
# functions...
###
xserver_has_xrandr() {
	if [ "${XFORCERANDR}" ]; then
		# force xrandr style configuration
		return 0
	elif [ "${XNOXRANDR}" ]; then
		# force legacy style configuration
		return 1
	fi

	# http://wiki.debian.org/XStrikeForce/HowToRandR12
	# As of today (20071015), the following drivers/boards support RandR 1.2:
	#  * the Intel driver on all boards (since 1.9.91)
	#  * the NV driver on G80 boards (since 2.0.95)
	#  * the ATI driver on r200/r300/r400 boards (since 6.7.191)
	#  * the MGA driver on all boards (since 1.9.99)

	# xserver driver
	# DRIVER="${1}"
	# device id of VGA hardware (lower case)
	# DEVICE="${2}"
	
	case "${1}" in
		ati|radeon)
			# find ${DEVICE} in a list of r200/r300/r400 device ids
			if [ -z "${2}" ] || ! grep -s -q "^${2}" \
				"/usr/share/fll-live-xorgconfig/xrandr/ati.ids"; then
				return 1
			fi
			return 0
			;;
		intel)
			return 0
			;;
		mga)
			return 0
			;;
		nv)
			# find ${DEVICE} in a list of G8x device ids
			if [ -z "${2}" ] || ! grep -s -q "^${2}" \
				"/usr/share/fll-live-xorgconfig/xrandr/nv.ids"; then
				return 1
			fi
			return 0
			;;
		radeonhd)
			return 0
			;;
		*)
			return 1
			;;
	esac
}

x_res_probe() {
	[ "${XNOXRESPROBE}" ] && return 0
	
	awk -F: -v driver="${1}" '
		BEGIN {
			cmd = "xresprobe " driver
			while ((cmd | getline) > 0) {
				sub(/^[ \t]+/,"",$2)
				if ($1 == "freq") {
					split($2,f," ")
					print "XHFREQ" "=\"" f[1] "\""
					print "XVFREQ" "=\"" f[2] "\""
					delete f
				}
				else 
					print "X" toupper($1) "=\"" $2 "\""
			}
		}'
}

do_start() {
	log_daemon_msg "${NAME}"
	log_action_begin_msg " detecting video hardware"
	
	if [ "${VERBOSE}" = "yes" ]; then
		XCFG_OPTS="${XCFG_OPTS} --verbose"
	fi

	# detect video hardware via fll_xserver_discover
	#     XMODULE XBOARDNAME XBUSID XVENDOR XDEVICE
	eval $(/usr/sbin/fll_xserver_discover 2>/dev/null)

	if [ "${XVENDOR}" = "10de" ] && [ "${XMODULE}" != "nv" ]; then
		# Emulate NVIsSupported() function of xf86-video-nv.
		# These boards are suspected to be supported by nv driver,
		# even though they are not in the list of explicitly known
		# board id's ...
		case "${XDEVICE}" in
			0040|0090|00c0|0120|0140|0160|0170|0180|01d0|0210|0220|0240|0250|0280|0290|02e4|0300|0310|0320|0330|0340|0390|03d0)
			XMODULE="nv"
			;;
		esac
	fi

	# detected virtualbox emulated VGA hardware
	if [ "${XMODULE}" = "vboxvideo" ]; then
		# create xrandr style configuration
		XFORCERANDR="1"
		# make sure the virtualbox-ose-guest-utils service is configured to start
		insert_initscript virtualbox-ose-guest-utils
	else
		remove_initscript virtualbox-ose-guest-utils
	fi

	# detected vmware emulated VGA hardware
	if [ "${XMODULE}" = "vmware" ]; then
		# create xrandr style configuration
		XFORCERANDR="1"
	fi

	if [ -z "${XMODULE}" ]; then
		if [ "${DPKG_ARCH}" != "powerpc" ]; then
			# for now we hardcode the fallback -> vesa
			XMODULE="vesa"
		else
			# fallback to fbdev on powerpc
			XMODULE="fbdev"
		fi
	fi

	log_end_msg 0
	
	log_daemon_msg "${NAME}"

	if [ "${XNEWMODULE}" ]; then
		# user override
		log_progress_msg "driver(*): ${XNEWMODULE}"
		XMODULE="${XNEWMODULE}"
	elif [ "${XMODULE}" ]; then
		log_progress_msg "driver: ${XMODULE}"
	fi
	XCFG_OPTS="${XCFG_OPTS} --driver '${XMODULE}'"

	# turn composite on for modules that support it well
	case "${XMODULE}" in
		intel)
			XCFG_OPTS="${XCFG_OPTS} --composite"
			;;
	esac

	if [ "${XVENDOR}" ] && [ "${XDEVICE}" ]; then
		log_progress_msg "pciid: ${XVENDOR}:${XDEVICE}"
	fi

	if [ "${XBUSID}" ]; then
		log_progress_msg "busid: ${XBUSID}"
		XCFG_OPTS="${XCFG_OPTS} --busid '${XBUSID}'"
	fi

	log_end_msg 0
	
	if [ "${XBOARDNAME}" ]; then
		log_daemon_msg "${NAME}"
		log_progress_msg "device: ${XBOARDNAME}"
		log_end_msg 0
		XCFG_OPTS="${XCFG_OPTS} --boardname '${XBOARDNAME}'"
	fi
	
	if xserver_has_xrandr "${XMODULE}" "${XDEVICE}"; then
		# driver is randr1.2 aware - let the xserver try its best
		# ... to do the right thing
		XCFG_OPTS="${XCFG_OPTS} --xrandr"
		
		if [ -z "${XOVERRIDE}" ]; then
			XCFG_OPTS="${XCFG_OPTS} --nocheat"
		else
			if [ "${XMODES}" ]; then
				XCFG_OPTS="${XCFG_OPTS} --mode '${XMODES}'"
			fi

			# warn about override semantic difference
			if [ "${XVERTREFRESH}" ] && [ -z "${XRATE}" ]; then
				log_warning_msg "ignoring vsync=${XVERTREFRESH}"
			fi

			if [ "${XRATE}" ]; then
				XCFG_OPTS="${XCFG_OPTS} --rate '${XRATE}'"
			fi
		fi
	else
		log_daemon_msg "${NAME}"
		if [ "${XNOXRESPROBE}" ]; then
			log_action_begin_msg " default monitor settings"
		else
			log_action_begin_msg " detecting monitor settings"
		fi
		
		# legacy style config, we need to probe for optimal X settings
		#     XID XRES XHFREQ XVFREQ XDISPTYPE
		eval $(x_res_probe ${XMODULE})

		# probed
		if [ "${XID}" ]; then
			# too long: log_progress_msg "id: ${XID}"
			XCFG_OPTS="${XCFG_OPTS} --modelname '${XID}'"
		fi
		
		if [ "${XMODES}" ]; then
			# cheatcode
			log_progress_msg "res(*): ${XMODES}"
			XCFG_OPTS="${XCFG_OPTS} --modes '${XMODES}'"
		elif [ "${XRES}" ]; then
			# just announce the highest res detected
			log_progress_msg "res: ${XRES%%\ *}"
			# probed
			XCFG_OPTS="${XCFG_OPTS} --modes '${XRES}'"
		fi
		
		if [ "${XHORIZSYNC}" ]; then
			# cheatcode
			XHORIZSYNC_MIN="${XHORIZSYNC%%-*}"
			XHORIZSYNC_MAX="${XHORIZSYNC##*-}"

			if [ "${XHORIZSYNC_MIN}" = "${XHORIZSYNC}" ]; then
				XHORIZSYNC_MIN="28"
			fi

			log_progress_msg "hfreq(*): ${XHORIZSYNC_MIN}-${XHORIZSYNC_MAX} kHz"
			XCFG_OPTS="${XCFG_OPTS} --horizsync '${XHORIZSYNC_MIN}-${XHORIZSYNC_MAX}'"
		elif [ "${XHFREQ}" ]; then
			log_progress_msg "hfreq: ${XHFREQ} kHz"
			# probed
			XCFG_OPTS="${XCFG_OPTS} --horizsync '${XHFREQ}'"
		fi

		# warn about override semantic difference
		if [ "${XRATE}" ] && [ -z "${XVERTREFRESH}" ]; then
			log_warning_msg "ignoring xrate=${XRATE}"
		fi			
		
		if [ "${XVERTREFRESH}" ]; then
			# cheatcode
			XVERTREFRESH_MIN="${XVERTREFRESH%%-*}"
			XVERTREFRESH_MAX="${XVERTREFRESH##*-}"

			if [ "${XVERTREFRESH_MIN}" = "${XVERTREFRESH}" ]; then
				XVERTREFRESH_MIN="50"
			fi

			log_progress_msg "vfreq(*): ${XVERTREFRESH_MIN}-${XVERTREFRESH_MAX} Hz"
			XCFG_OPTS="${XCFG_OPTS} --vertrefresh '${XVERTREFRESH_MIN}-${XVERTREFRESH_MAX}'"
		elif [ "${XVFREQ}" ]; then
			# probed
			XVERTREFRESH_MIN="${XVFREQ%%-*}"
			XVERTREFRESH_MAX="${XVFREQ##*-}"

			if [ "${XVERTREFRESH_MAX}" -ge "85" ]; then
				# raise minimum vertical refresh threshold
				XVERTREFRESH_MIN="73"
				log_progress_msg "vfreq(+): ${XVERTREFRESH_MIN}-${XVERTREFRESH_MAX} Hz"
			else
				log_progress_msg "vfreq: ${XVERTREFRESH_MIN}-${XVERTREFRESH_MAX} Hz"
			fi

			XCFG_OPTS="${XCFG_OPTS} --vertrefresh '${XVERTREFRESH_MIN}-${XVERTREFRESH_MAX}'"
		fi

		# cheatcode
		if [ "${XNOMODELINES}" ]; then
			XCFG_OPTS="${XCFG_OPTS} --no-modelines"
		fi

		log_end_msg 0
	fi

	# x_res_probe() may also export this variable
	# force colordepth of 16 for vesa, this helps with antiquated
	# graphics chipsets.
	if [ "${XDEPTH}" ]; then
		XCFG_OPTS="${XCFG_OPTS} --colordepth '${XDEPTH}'"
	elif [ "${XMODULE}" = "vesa" ]; then
		XCFG_OPTS="${XCFG_OPTS} --colordepth 16"
	fi

	# write the configuration to file
	eval "/usr/sbin/fll_xorgconfig ${XCFG_OPTS}"
}

case "${1}" in
	start)
		do_start
		;;
	stop)
		;;
	restart|force-reload)
		echo "Error: argument '${1}' not supported" >&2
		exit 3
		;;
	*)
		echo "Usage: ${NAME} {start|stop}" >&2
		exit 3
		;;
esac

:
